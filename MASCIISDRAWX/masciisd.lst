                        ; --------------------------------------
                        ; zasm: assemble "masciisd.asm"
                        ; date: 2020-12-22 13:51:00
                        ; --------------------------------------


                        ; ------------------MASCIISDRAWX
                        ;	MASCIISDRAWX
                        ;	(C) Fred Rique (farique) 2020
                        ;	github.com/farique1/8bitcode
                        ; ------------------------
                        
                        ; ------------------DOCS
                        ; KEYS:
                        	; H					help
                        	;    ARROWS				   navigate
                        	;    ANY KEY			   exit
                        	; ARROWS MOUSE			move
                        	;  + SHIFT				move * 4
                        	; SPACE BUTTON1			draw
                        	; BS BUTTON2			erase (default space char)
                        	; M					toggle mouse
                        	; Z X					cycle characters
                        	;  + SHIFT				cycle characters * 16
                        	; 7 8					cycle cursor color
                        	; 9 0					cycle border color
                        	; N 					pick character under cursor
                        	; B					cycle box modes:
                        	;					 filled box w/ curr char
                        	;					 hollow box with curr char
                        	;					 box with lines
                        	;					 box with lines adding them
                        	;					 box with sequential chars
                        	;    ENTER BUTTON1 SPACE	   draw
                        	;    ESC BS C BUTTON2		   cancel
                        	; C					copy area of screen / enter paste
                        	; V					paste previous copy
                        	;    ENTER BUTTON1 SPACE	   paste
                        	;    BS BUTTON2			   erase area
                        	;    C V				   cancel
                        	; /					show character map picker
                        	;    ENTER BUTTON1 SPACE	   pick and leave
                        	;    BS BUTTON2			   pick erase char
                        	;    ESC / 				   leave
                        	; ?					change the current character by typing
                        	;    ESC				   leave without changing
                        	; T					enter text by typing
                        	;    ENTER CTRL + STOP		    leave
                        	; W A S D				scroll up left down right
                        	; Q E					flip vertical horizontal
                        	;  + SHIFT				also flip patterns
                        	; F					swap screen buffers
                        	; U					undo box or text
                        	; Y					quick save (lose undo)
                        	; O I					save load file
                        	;					   ^ = more files
                        	;    ARROWS				   choose a file
                        	;    ENTER(2x)			   pick and save or load the file
                        	;    SPACE				   write a name
                        	;    E				   change the extension to list
                        	;    D				   delete the file (ENTER confirm)
                        	;    ESC				   cancel
                        	; ESC					clear screen
                        	;  + SHIFT				clear screen w/ curr char
                        	;  + CTRL				reset screen
                        	; Q + CTRL				quit
                        	; .					edit characters mode
                        	;    ARROWS MOUSE			   move
                        	;     + SHIFT			   move * 4
                        	;    SPACE BUTTON1		   toggle bit/choose character
                        	;    Z X				   cycle characters
                        	;     + SHIFT			   cycle characters * 16
                        	;    1 2				   cycle foreground color
                        	;    3 4				   cycle background color
                        	;    W A S D			   scroll
                        	;    Q E				   flip vert horz
                        	;    R F				   rotate
                        	;    H				   invert
                        	;    J				   create checkerboard
                        	;    K				   clear
                        	;    L				   fill
                        	;    C				   copy
                        	;    V				   paste all
                        	;     + SHIFT			   paste pattern
                        	;	+ CTRL			   paste color				
                        	;    U				   undo
                        	;    Y				   quick save (lose undo)
                        	;    TAB				   swap working characters
                        	;    BS				   save working characters
                        	;    ESC				   exit without saving
                        	;    .				   exit
                        ; TODO
                        	; shift constrain to straight lines
                        	; key to show position of cursor. VRAM, x and y
                        	; basic, error detection for file not found
                        	; basic, mouse support
                        	; basic, file filter instead of extensiom
                        	; make draw box use its own ram variable for the character
                        	; use COPYTOVRAM more, see char map fonts
                        	; check all potential writings outside the screen
                        	; replace all WRTVRM with WRTVRMS adjusting routines accordingly
                        ; IDEAS
                        	; crop and flip the paste buffer
                        	; swap to a second paste buffer if available
                        ; ------------------------
                        
                        ; ------------------HEADER
B000:                   	org	0xb000		; start memory location
                        
B000: FE                	db	0xfe			; indicate it is a bin file
B001: 07B0              	dw	bascm			; start address
B003: 48D7              	dw	_end			; end address
B005: 1DB0              	dw	start			; execute address
                        ; ------------------------
                        
                        ; ------------------BODY
                        #include "masciiIN.asm"		; initializations
                        ; ------------------INITIALISATION
                        
                        					; for use in basic
B007: 00                bascm:db	0x00			; communication with basic (<to >from)
                        					; <0=save,<1=load,<&hff=quit,
                        					; >&h20=cancel requester
                        					; flags (bits)
B008: 00                flags:db	0x00			; 7=quit,6=mouse,5=rect,4=dis gen input,
                        					; 3=paste box,2=char map,1=edit char
B009: 00                	db	0x00			; 7=grid trigger					
B00A: C38DB4   [10]     swscr:jp	clsrestscr		; called from basic, show the screen to BSAVE
                        					; start and return
B00D:                   return:				; entry point when returning from basic
B00D: 3A07B0   [13]     	ld	a,(bascm)		; get basic communication byte
B010: FE01     [20]     	cp	0x01			; was a load?
B012: 2838     [27|32]  	jr	z,sstr1		; if so, return initializing sprites
B014: FE00     [34]     	cp	0x00			; was a save?
B016: 282B     [41|46]  	jr	z,sstr2		; if so, return initializing sprites all
B018: CD8DB4   [58]     	call	clsrestscr		; if canceled, restore drawing
B01B: 1832     [70]     	jr	sstr3			; return without initializing sprites
B01D:                   start:
B01D: CDCEB0   [17]     	call	checkmouse		; check if there is a mouse
B020: 3E20     [24]     	ld	a,32			; 32 columns
B022: 32AFF3   [37]     	ld	(LINL32),a		; put on the variable
B025: CD6F00   [54]     	call	init32		; initialize screen 1
B028: CDCC00   [71]     	call	erafnk		; hide function keys display
B02B: 3A61C4   [84]     	ld	a,(scrat)		; get fore color attribute
B02E: 32E9F3   [97]     	ld	(FORCLR),a		; put fore color on memory
B031: 3A62C4   [110]    	ld	a,(scrat+1)		; get back color attribute
B034: 32EAF3   [123]    	ld	(BAKCLR),a		; put back color on memory
B037: 3A63C4   [136]    	ld	a,(scrat+2)		; get bord color attribute
B03A: 32EBF3   [149]    	ld	(BDRCLR),a		; put bord color on memory
B03D: CD6200   [166]    	call	chgclr		; change screen colors
B040: CDC4C2   [183]    	call	setundo		; copy screen for undo
B043: CD60B0   [17]     sstr2:call	initsprmem		; auto fill sprite VRAM addresses in RAM table
B046: 3A64C4   [30]     	ld	a,(scrat+3)		; get character color attribute
B049: 3250C5   [43]     	ld	(editoncl),a	; save in working char buffer (prep for high color)	
B04C: CD8FB0   [17]     sstr1:call	initsprites		; copy sprites attributes and patters from RAM
B04F: 21A9FC   [10]     sstr3:ld	hl,CSRSW		; disable text cursor
B052: 36FF     [20]     	ld	(hl),0xff		;
B054: 3A33C4   [33]     	ld	a,(curat+6)		; get current character
B057: CD1CB5   [50]     	call	getcharshape	; put character shape on sprite
B05A: CD2DB5   [67]     	call	getcharcolor	; put character color on sprite
B05D: C3E2B0   [77]     	jp	mainloop		; go to main loop
                        
B060:                   initsprmem:				; auto fill sprite VRAM addresses in RAM table
B060: 3A2FC5   [13]     	ld	a,(splastal+8)	; get sprite amount
B063: 47       [17]     	ld	b,a			; put in decremental counter
B064: 0E00     [24]     	ld	c,0			; reset sprite number counter
B066: 116CC4   [34]     	ld	de,spfrstal		; get RAM attributes start, y pos
B069: 13       [ 6]     linme:inc	de			; go to x pos
B06A: 13       [12]     	inc	de			; go to sprite number
B06B: 79       [16]     	ld	a,c			; get sprite number counter
B06C: 12       [23]     	ld	(de),a		; save in RAM
B06D: 13       [29]     	inc	de			; go to color
B06E: 13       [35]     	inc	de			; go to sprite pattern pos low byte
B06F: D5       [46]     	push	de			; save the RAM address
B070: CD8400   [63]     	call	calpat		; get VRAM sprite pattern address
B073: D1       [73]     	pop	de			; restore RAM address
B074: 7D       [77]     	ld	a,l			; get VRAM address low byte
B075: 12       [84]     	ld	(de),a		; save in RAM
B076: 13       [90]     	inc	de			; go to sprite pattern pos high byte
B077: 7C       [94]     	ld	a,h			; get VRAM address high byte
B078: 12       [101]    	ld	(de),a		; save in RAM
B079: 79       [105]    	ld	a,c			; get sprite number counter
B07A: D5       [116]    	push	de			; save RAM address
B07B: CD8700   [133]    	call	calatr		; get VRAM sprite attribute address
B07E: D1       [143]    	pop	de			; restore RAM address
B07F: 13       [149]    	inc	de			; go to sprite attribute pos low byte
B080: 7D       [153]    	ld	a,l			; get VRAM address low byte
B081: 12       [160]    	ld	(de),a		; save in RAM
B082: 13       [166]    	inc	de			; go to sprite attribute pos high byte
B083: 7C       [170]    	ld	a,h			; get VRAM address high byte
B084: 12       [177]    	ld	(de),a		; save in RAM
B085: 3E0A     [184]    	ld	a,0x0a		; amount to jump
B087: CDE3C3   [201]    	call	add8to16		; jump 7 RAM addresses
B08A: 79       [205]    	ld	a,c			; get sprite number counter
B08B: 0C       [209]    	inc	c			; increment it
B08C: 10DB     [217|222]	djnz	linme			; decremental counter, if not 0, loop
B08E: C9       [227]    	ret
                        
B08F:                   initsprites:			; initialize the sprites
                        					; send all sprites to 290 y pos (hide all)
B08F: 0620     [ 7]     	ld	b,0x20		; get all sprites attributes
B091: 21001B   [17]     	ld	hl,0x1b00		; get VRAM attribute address (pos y)
B094: 36D1     [10]     lisp3:ld	(hl),209		; pos y to 209. hide
B096: 23       [16]     	inc	hl			; increment to pos x
B097: 23       [22]     	inc	hl			; increment to pattern number
B098: 23       [28]     	inc	hl			; increment to color
B099: 23       [34]     	inc	hl			; increment to pos y
B09A: 10F8     [42|47]  	djnz	lisp3			; do until finished
                        					; copy sprites attributes to VRAM
B09C: 3A2FC5   [55]     	ld	a,(splastal+8)	; get sprite amount
B09F: 47       [59]     	ld	b,a			; put in B
B0A0: 21001B   [69]     	ld	hl,0x1b00		; get VRAM attribute address
B0A3: 116CC4   [79]     	ld	de,spfrstal		; get RAM attributes start
B0A6: 0E04     [86]     	ld	c,0x04		; amount to copy
B0A8: CDE1C2   [17]     lisp1:call	copytovram		; copy to VRAM updating HL and DE
B0AB: 3E0D     [24]     	ld	a,0x0d		; amount of RAM to jump over
B0AD: CDE3C3   [41]     	call	add8to16		; add to DE
B0B0: 10F6     [49|54]  	djnz	lisp1			; loop
                        					; copy sprites patterns to VRAM
B0B2: 3A2FC5   [62]     	ld	a,(splastal+8)	; get sprite amount
B0B5: 47       [66]     	ld	b,a			; put in B
B0B6: 210038   [76]     	ld	hl,0x3800		; get VRAM pattern address
B0B9: 1175C4   [86]     	ld	de,spfrstal+9	; get RAM pattern start
B0BC: 0E08     [93]     	ld	c,0x08		; amount to copy
B0BE: CDE1C2   [17]     lisp2:call	copytovram		; copy to VRAM updating HL and DE
B0C1: 3E09     [24]     	ld	a,0x09		; amount of RAM to jump over
B0C3: CDE3C3   [41]     	call	add8to16		; add to DE
B0C6: 10F6     [49|54]  	djnz	lisp2			; loop
                        					; update cursor colors
B0C8: 0600     [56]     	ld	b,0x00		; cursor color offset none
B0CA: CD4DB5   [73]     	call	cursorcolor		; color the cursors
B0CD: C9       [83]     	ret
                        
B0CE:                   checkmouse:				; check if a mouse is present
B0CE: 06FF     [ 7]     	ld	b,0xff		; try for 255 cycles
B0D0: CD70B7   [17]     lchmo:call	getmouse		; get mouse offset
B0D3: 7C       [21]     	ld	a,h			; get x offset
B0D4: A5       [25]     	and	l			; and with Y offset
B0D5: FEFF     [32]     	cp	0xff			; are both 255?
B0D7: 2803     [39|44]  	jr	z,turnoffmouse	; if so, turn off the mouse
B0D9: 10F5     [47|52]  	djnz	lchmo			; decrease counter and loop
B0DB: C9       [57]     	ret
B0DC:                   turnoffmouse:			; turn off mouse
B0DC: 0640     [ 7]     	ld	b,0b01000000	; use bit 6
B0DE: CAE9C3   [17|17]  	jp	z,toggleflags	; toggle it
B0E1: C9       [27]     	ret
                        #include "masciiML.asm"		; mail loop
                        ; ------------------MAIN LOOP
                        
B0E2:                   mainloop:				; - always do section
B0E2: CD9C00   [17]     	call	chsns			; check keyboard buffer
B0E5: C4DCC0   [27|34]  	call	nz,readmainkeys	; if keys check main keys
B0E8: CDE0B4   [44]     	call	drawcsr		; draw cursor sprite
                        					; - general input section
B0EB: 3A08B0   [57]     	ld	a,(flags)		; look for flag byte
B0EE: CB67     [65]     	bit	4,a			; test bit 5
B0F0: 2015     [72|77]  	jr	nz,smgin		; if 1, no general input 
B0F2: CDF2B4   [89]     	call	drawchcsr		; draw character sprites
B0F5: CD12B7   [106]    	call	checktrigger	; check button/SPACE - output NZ if pressed
B0F8: C4A1B4   [116|123]	call	nz,drawchar		; if pressed draw character
B0FB: CD20B7   [133]    	call	checkbutton2	; check button 2
B0FE: C4AEB4   [143|150]	call	nz,erasechar	; if pressed cancel rectangle
B101: CD9C00   [160]    	call	chsns			; check keyboard buffer
B104: C4FBBF   [170|177]	call	nz,readgenkeys	; if key check general which
B107:                   smgin:				; - mouse section
B107: 3A08B0   [13]     	ld	a,(flags)		; look for flag byte
B10A: CB77     [21]     	bit	6,a			; test bit 6
B10C: 2006     [28|33]  	jr	nz,smmse		; if 1, no mouse
B10E: CD70B7   [45]     	call	getmouse		; if set, mouse - output HL
B111: CD33B7   [62]     	call	movecursor		; move the cursors - input HL
B114:                   smmse:				; - rectangle section
B114: 3A08B0   [13]     	ld	a,(flags)		; look for flag byte
B117: CB6F     [21]     	bit	5,a			; test bit 5
B119: 2815     [28|33]  	jr	z,smrct		; if 0, no rectangle 
B11B: CD04B8   [45]     	call	showrectcurs	; get rectangle data
B11E: CD9C00   [62]     	call	chsns			; check keyboard buffer
B121: C453C1   [72|79]  	call	nz,readrectkeys	; if keys check rectangle keys
B124: CD12B7   [89]     	call	checktrigger	; check button/SPACE - output NZ if pressed
B127: C455B8   [99|106] 	call	nz,activaterect	; if pressed activate rectangle
B12A: CD20B7   [116]    	call	checkbutton2	; check button 2
B12D: C4B6B8   [126|133]	call	nz,cancelrect	; if pressed cancel rectangle
B130:                   smrct:				; - paste box section
B130: 2108B0   [10]     	ld	hl,flags		; get flags byte
B133: CB5E     [22]     	bit	3,(hl)		; test bit 3
B135: 2817     [29|34]  	jr	z,smpbx		; if 0, no paste box 
B137: CBE6     [44]     	set	4,(hl)		; force set disable general input
B139: CD73B9   [61]     	call	showpastebox	; show paste box
B13C: CD9C00   [78]     	call	chsns			; check keyboard buffer
B13F: C482C1   [88|95]  	call	nz,readpastbxkeys	; if keys check paste box keys
B142: CD12B7   [105]    	call	checktrigger	; check button/SPACE - output NZ if pressed
B145: C4B2B9   [115|122]	call	nz,pastethebox	; if pressed paste the paste box
B148: CD20B7   [132]    	call	checkbutton2	; check button 2
B14B: C4C2B9   [142|149]	call	nz,erasewithbox	; if pressed cancel paste box
B14E:                   smpbx:				; - character map section
B14E: 2108B0   [10]     	ld	hl,flags		; get flags byte
B151: CB56     [22]     	bit	2,(hl)		; test bit 3
B153: 2815     [29|34]  	jr	z,smcmp		; if 0, no character map
B155: CD23B2   [46]     	call	chosefrommap	; choose character from map
B158: CD9C00   [63]     	call	chsns			; check keyboard buffer
B15B: C4C0C1   [73|80]  	call	nz,readchmapkeys	; if keys check character map keys
B15E: CD12B7   [90]     	call	checktrigger	; check button/SPACE - output NZ if pressed
B161: C481B2   [100|107]	call	nz,getfrommap	; if pressed get the selected character
B164: CD20B7   [117]    	call	checkbutton2	; check button 2
B167: C47CB2   [127|134]	call	nz,geterasechar	; if pressed cancel character map
B16A:                   smcmp:				; - edit characters section
B16A: 2108B0   [10]     	ld	hl,flags		; get flags byte
B16D: CB4E     [22]     	bit	1,(hl)		; test bit 3
B16F: 281A     [29|34]  	jr	z,smedc		; if 0, no edit char
B171: CD33BC   [46]     	call	insidecharmap	; function according to screen location
B174: 2815     [53|58]  	jr	z,smedc		; if 0, no edit char
B176: CD45BC   [70]     	call	insideeditarea	; function according to screen location
B179: CD9C00   [87]     	call	chsns			; check keyboard buffer
B17C: C4E3C1   [97|104] 	call	nz,readedchkeys	; if keys check character map keys
B17F: CD12B7   [114]    	call	checktrigger	; check button/SPACE - output NZ if pressed
B182: C4B5BC   [124|131]	call	nz,triggeredit	; if pressed get the selected character
B185: CD20B7   [141]    	call	checkbutton2	; check button 2
B188: C402BC   [151|158]	call	nz,savewrkchrs	; if pressed cancel character map
B18B:                   smedc:				; - quit or loop
B18B: 2108B0   [10]     	ld	hl,flags		; look for flag byte
B18E: CB7E     [22]     	bit	7,(hl)		; test bit 7
B190: CAE2B0   [32|32]  	jp	z,mainloop		; if 0, loop
B193: CD9DC3   [49]     	call	hidecur		; hide the cursor
B196: CDA6C3   [66]     	call	hidecharcur		; hide the character cursor
B199: C9       [76]     	ret
                        #include "masciiMI.asm"		; misc routines
                        ; ------------------MISCELLANEOUS
                        
                        ; ------------------IO
                        
B19A:                   fileinput:				; load drawing
B19A: CD5601   [17]     	call	kilbuf		; clear keyboard buffer
B19D: 21A9FC   [27]     	ld	hl,CSRSW		; enable text cursor
B1A0: 3600     [37]     	ld	(hl),0x00		;
B1A2: 2107B0   [47]     	ld	hl,bascm		; get basic communication byte
B1A5: 3601     [57]     	ld	(hl),0x01		; insert load flag
B1A7: 2108B0   [67]     	ld	hl,flags		; get flags byte
B1AA: CBFE     [82]     	set	7,(hl)		; set quit flag
B1AC: CD74B4   [99]     	call	clssavescr		; save current drawing
B1AF: C9       [109]    	ret
                        
B1B0:                   fileoutput:				; save drawing
B1B0: CD5601   [17]     	call	kilbuf		; clear keyboard buffer
B1B3: 21A9FC   [27]     	ld	hl,CSRSW		; enable text cursor
B1B6: 3600     [37]     	ld	(hl),0x00		;
B1B8: 2107B0   [47]     	ld	hl,bascm		; get basic communication byte
B1BB: 3600     [57]     	ld	(hl),0x00		; insert load flag
B1BD: 2108B0   [67]     	ld	hl,flags		; get flags byte
B1C0: CBFE     [82]     	set	7,(hl)		; set quit flag
B1C2: CD74B4   [99]     	call	clssavescr		; save current drawing
B1C5: C9       [109]    	ret
                        
B1C6:                   setquit:				; prepare to exit the ML program
B1C6: 2107B0   [10]     	ld	hl,bascm		; get basic communication byte
B1C9: 36FF     [20]     	ld	(hl),0xff		; insert quit flag
B1CB: 11C4C5   [30]     	ld	de,textquit		; RAM position of text
B1CE: 214A19   [40]     	ld	hl,0x194a		; text VRAM position
B1D1: CDB2B3   [57]     	call	areyousure		; call confirmation
B1D4: C0       [62|68]  	ret	nz			; if not, return
B1D5: 2108B0   [72]     	ld	hl,flags		; get flags byte
B1D8: CBFE     [87]     	set	7,(hl)		; set quit flag
B1DA: CD5601   [104]    	call	kilbuf		; clear keyboard buffer
B1DD: C9       [114]    	ret
                        
                        ; ------------------CHARACTER MAP
                        
B1DE:                   showcharmap:			; show a character map to choose from
                        					; save VRAM content under character map
B1DE: 216718   [10]     	ld	hl,0x1867		; get start VRAM position for box
B1E1: 2268C4   [26]     	ld	(rectt+1),hl	; save in mem
B1E4: 211212   [36]     	ld	hl,0x1212		; get width(H) and height(L) 
B1E7: 226AC4   [52]     	ld	(rectt+3),hl	; save in mem (reversed)
B1EA: 2A68C4   [68]     	ld	hl,(rectt+1)	; VRAM position from
B1ED: 110014   [78]     	ld	de,VRBUF4		; VRAM position to
B1F0: 015002   [88]     	ld	bc,0x0250		; length
B1F3: CD0BC3   [105]    	call	streamvv		; copy
                        					; save current character, draw border and restore char
B1F6: 3A33C4   [118]    	ld	a,(curat+6)		; get current character
B1F9: F5       [129]    	push	af			; save it
B1FA: 3EFF     [136]    	ld	a,0xff		; get new character
B1FC: 3233C4   [149]    	ld	(curat+6),a		; save as current
B1FF: CD2CBA   [166]    	call	drawboxhol		; draw box border with new char
B202: F1       [176]    	pop	af			; restore current character
B203: 3233C4   [189]    	ld	(curat+6),a		;
B206: 2A2DC4   [205]    	ld	hl,(curat)		; get current cursor position
B209: 2231C4   [221]    	ld	(curat+4),hl	; save for later
B20C: 216080   [231]    	ld	hl,0x8060		; get middle of the screen
B20F: 222DC4   [247]    	ld	(curat),hl		; put on current cursor position
                        					; draw character map
B212: 218818   [257]    	ld	hl,0x1888		; top left position for char map
B215: CD1EC3   [274]    	call	createcharmap	; draw the character map
                        					; set flags
B218: 2108B0   [284]    	ld	hl,flags		; get flags byte
B21B: CBD6     [299]    	set	2,(hl)		; set char map flag
B21D: CBE6     [314]    	set	4,(hl)		; set dis gen input flag
B21F: CD5601   [331]    	call	kilbuf		; clear keyboard buffer
B222: C9       [341]    	ret
                        
B223:                   chosefrommap:			; choose from the character map
                        					; put shape of selected char on cursor
B223: 2A2DC4   [16]     	ld	hl,(curat)		; get x,y (read bytes pos inverted)
B226: CD10C4   [33]     	call	vrampos		; get the VRAM position
B229: CD4A00   [50]     	call	rdvrm			; read VRAM from position
B22C: CD1CB5   [67]     	call	getcharshape	; change the character cursor shape
                        					; put color of selected char on cursor, inverted
B22F: CDA9BE   [84]     	call	getcolorfrchr	; get color from VRAM table
B232: F5       [95]     	push	af			; save it
B233: 2A1CC5   [111]    	ld	hl,(spcharac+6)	; character cursor VRAM attribute pos y
B236: 23       [117]    	inc	hl			; inc to color
B237: 23       [123]    	inc	hl			;
B238: 23       [129]    	inc	hl			;
B239: E60F     [136]    	and	0b00001111		; clip foreground color
B23B: CD4D00   [153]    	call	wrtvrm		; apply
B23E: 2A2DC5   [169]    	ld	hl,(spbckgrd+6)	; background cursor VRAM attribute pos y
B241: 23       [175]    	inc	hl			; inc to color
B242: 23       [181]    	inc	hl			;
B243: 23       [187]    	inc	hl			;
B244: F1       [197]    	pop	af			; restore character color
B245: E6F0     [204]    	and	0b11110000		; clip background color
B247: CB3F     [212]    	srl	a			; slide to low nibble
B249: CB3F     [220]    	srl	a			;
B24B: CB3F     [228]    	srl	a			;
B24D: CB3F     [236]    	srl	a			;
B24F: CD4D00   [253]    	call	wrtvrm		; apply
                        
B252: 3A2DC4   [266]    	ld	a,(curat)		; get pos y
B255: C604     [273]    	add	4			; offset cursor
B257: E6F8     [280]    	and	0b11111000		; step by 8 increments
B259: 3D       [284]    	dec	a			; adjust for y sprite offset
B25A: 2A1CC5   [300]    	ld	hl,(spcharac+6)	; character cursor VRAM attribute pos y
B25D: CD4D00   [317]    	call	wrtvrm		; write pos y to VRAM
B260: 2A2DC5   [333]    	ld	hl,(spbckgrd+6)	; background cursor VRAM attribute pos y
B263: CD4D00   [350]    	call	wrtvrm		; write pos y to VRAM
                        
B266: 3A2EC4   [363]    	ld	a,(curat+1)		; get pos x
B269: C604     [370]    	add	4			; offset cursor
B26B: E6F8     [377]    	and	0b11111000		; step by 8 increments
B26D: 2A1CC5   [393]    	ld	hl,(spcharac+6)	; character cursor VRAM attribute pos y
B270: 23       [399]    	inc	hl			; inc to pos x
B271: CD4D00   [416]    	call	wrtvrm		; write pos y to VRAM
B274: 2A2DC5   [432]    	ld	hl,(spbckgrd+6)	; character cursor VRAM attribute pos y
B277: 23       [438]    	inc	hl			; inc to pos x
B278: CD4D00   [455]    	call	wrtvrm		; write pos y to VRAM
B27B: C9       [465]    	ret
                        
B27C:                   geterasechar:			; get erase char from character map
B27C: 0135C4   [10]     	ld	bc,curat+8		; get adrress for erase character
B27F: 1803     [22]     	jr	sgfm1			; skip get current character
B281:                   getfrommap:				; get a new character from the char map
B281: 0133C4   [10]     	ld	bc,curat+6		;  get adrress for current character
B284: 2A2DC4   [16]     sgfm1:ld	hl,(curat)		; get cursor xy position
B287: CD10C4   [33]     	call	vrampos		; get cursor VRAM address
B28A: CD4A00   [50]     	call	rdvrm			; read char beneath it
B28D: 02       [57]     	ld	(bc),a		; put on current or erase character address
B28E:                   cancelcharmap:			; cancel char map keeping the original character
B28E: 3A33C4   [13]     	ld	a,(curat+6)		; get current character
B291: CD1CB5   [30]     	call	getcharshape	; restore chracter cursor shape
B294: CD2DB5   [47]     	call	getcharcolor	; restore chracter cursor color
                        					; restore cursor position	
B297: 2A31C4   [63]     	ld	hl,(curat+4)	; get saved x,y cursor pos
B29A: 222DC4   [79]     	ld	(curat),hl		; put on current variable
                        					; restore background area
B29D: 210014   [89]     	ld	hl,VRBUF4		; VRAM position from
B2A0: ED5B68C4 [109]    	ld	de,(rectt+1)	; VRAM position to
B2A4: 015002   [119]    	ld	bc,0x0250		; length
B2A7: CD0BC3   [136]    	call	streamvv		; copy
                        					; reset flags
B2AA: 2108B0   [146]    	ld	hl,flags		; get flags byte
B2AD: CB96     [161]    	res	2,(hl)		; set char map flag
B2AF: CBA6     [176]    	res	4,(hl)		; set dis gen input flag
B2B1: CD28B7   [193]    	call	waittrgrls		; wait for trigger release
B2B4: CD5601   [210]    	call	kilbuf		; clear keyboard buffer
B2B7: C9       [220]    	ret
                        
                        ; ------------------TEXT
                        
B2B8:                   entertext:				; type text on the screen
B2B8: CDC4C2   [17]     	call	setundo		; copy screen for undo
B2BB: 21A9FC   [27]     	ld	hl,CSRSW		; enable text cursor
B2BE: 3600     [37]     	ld	(hl),0x00		;
B2C0: CD9DC3   [54]     	call	hidecur		; hide the cursor
B2C3: CDA6C3   [71]     	call	hidecharcur		; hide the character cursors
                        
B2C6: 2A2DC4   [87]     	ld	hl,(curat)		; get cursor x,y
B2C9: 7D       [91]     	ld	a,l			; put cursor x in A
B2CA: C604     [98]     	add	4			; offset cursor
B2CC: E6F8     [105]    	and	0b11111000		; step by 8 increments
B2CE: 0F       [109]    	rrca				; divide by 2
B2CF: 0F       [113]    	rrca				; divide by 4
B2D0: 0F       [117]    	rrca				; divide by 8
B2D1: 3C       [121]    	inc	a			; compensate for POSIT
B2D2: 6F       [125]    	ld	l,a			; put back to L
B2D3: 7C       [129]    	ld	a,h			; put cursor y in A
B2D4: C604     [136]    	add	4			; offset cursor
B2D6: E6F8     [143]    	and	0b11111000		; step by 8 increments
B2D8: 0F       [147]    	rrca				; divide by 2
B2D9: 0F       [151]    	rrca				; divide by 4
B2DA: 0F       [155]    	rrca				; divide by 8
B2DB: 3C       [159]    	inc	a			; compensate for POSIT
B2DC: 67       [163]    	ld	h,a			; put back to H
                        
B2DD: CDC600   [180]    	call	posit			; locate on the screen
B2E0: CD5601   [197]    	call	kilbuf		; clear keyboard buffer
B2E3: CDB100   [214]    	call	inlin			; enter text
B2E6: 21A9FC   [224]    	ld	hl,CSRSW		; disable text cursor
B2E9: 36FF     [234]    	ld	(hl),0xff		;
B2EB: C9       [244]    	ret
                        
B2EC:                   getcharkey:				; type a key to get a character
B2EC: CD5601   [17]     	call	kilbuf		; clear keyboard buffer
B2EF: CD9DC3   [34]     	call	hidecur		; hide the cursor
                        
B2F2: 3A2DC4   [47]     	ld	a,(curat)		; get pos y
B2F5: C604     [54]     	add	4			; offset cursor
B2F7: E6F8     [61]     	and	0b11111000		; step by 8 increments
B2F9: 3D       [65]     	dec	a			; decrement to compensate sprite offset
B2FA: 2A0BC5   [81]     	ld	hl,(sptextent+6)	; text entry sprite VRAM attribute pos y
B2FD: CD4D00   [98]     	call	wrtvrm		; write pos y to VRAM
B300: 3A2EC4   [111]    	ld	a,(curat+1)		; get pos x
B303: C604     [118]    	add	4			; offset cursor
B305: E6F8     [125]    	and	0b11111000		; step by 8 increments
B307: 2A0BC5   [141]    	ld	hl,(sptextent+6)	; text entry sprite VRAM attribute pos y
B30A: 23       [147]    	inc	hl			; inc to pos x
B30B: CD4D00   [164]    	call	wrtvrm		; write pos y to VRAM
                        
B30E: CD9F00   [181]    	call	chget			; get a character
B311: F5       [192]    	push	af			; save it
B312: 3ED1     [199]    	ld	a,209			; get 209 as y pos to hide the text entry sprite 
B314: 2A0BC5   [215]    	ld	hl,(sptextent+6)	; sprite 3 VRAM attribute pos y
B317: CD4D00   [232]    	call	wrtvrm		; write pos y to VRAM
B31A: F1       [242]    	pop	af			; get the character back
B31B: FE1B     [249]    	cp	0x1b			; is ESC?
B31D: C8       [254|260]	ret	z			; if it is, return
B31E: 3233C4   [267]    	ld	(curat+6),a		; save the character as the current character
B321: CD1CB5   [284]    	call	getcharshape	; put the shape on the cursor
B324: CD2DB5   [301]    	call	getcharcolor	; put the color on the cursor
B327: C9       [311]    	ret
                        
B328:                   writetext:				; write text on screen
                        					; input: DE=RAM pos,HL=VRAM pos
                        					; special chars: 0xff=new line,0x01-0x1f=space amount,0x00=end
B328: 1B       [ 6]     	dec	de			; dec RAM pos to compensate first RAM advance
B329: E5       [17]     	push	hl			; save initial VRAM pos
B32A: 13       [ 6]     lwrtx:inc	de			; advance one RAM text position
B32B: 0601     [13]     	ld	b,1			; assign 1 for the looping character amount
B32D: 1A       [20]     	ld	a,(de)		; get first character
B32E: FE00     [27]     	cp	0x00			; is 0?
B330: 2820     [34|39]  	jr	z,swext		; if so, jump to end text routine
B332: FEFF     [41]     	cp	0xff			; is 255?
B334: 200D     [48|53]  	jr	nz,swret		; if not, jump over new line routine
B336: E1       [58]     	pop	hl			; get start of line position
B337: F5       [69]     	push	af			; save the character value
B338: 3E20     [76]     	ld	a,0x20		; get 32 (down one line on the screen VRAM)
B33A: EB       [80]     	ex	de,hl			; exchange RAM<>VRAM positions for the add routine
B33B: CDE3C3   [97]     	call	add8to16		; add 32 to VRAM position (now on DE)
B33E: EB       [101]    	ex	de,hl			; exchange RAM<>VRAM back
B33F: F1       [111]    	pop	af			; restore character value
B340: E5       [122]    	push	hl			; save start of line position
B341: 18E7     [134]    	jr	lwrtx			; loop to get new character
B343: FE20     [ 7]     swret:cp	0x20			; compare to 31
B345: 3003     [14|19]  	jr	nc,lwspc		; if greater, jump over spaces routine
B347: 47       [18]     	ld	b,a			; get amount of spaces (byte value)
B348: 3E20     [25]     	ld	a,0x20		; define character as space
B34A: CD4D00   [17]     lwspc:call	wrtvrm		; write on the screen
B34D: 23       [23]     	inc	hl			; advance screen position
B34E: 10FA     [31|36]  	djnz	lwspc			; decrease character amount and print another if not 0
B350: 18D8     [43]     	jr	lwrtx			; loop to get new character
B352: E1       [10]     swext:pop	hl			; restore HL (to tidy the stack) before returning
B353: C9       [20]     	ret
                        
B354:                   showhelp:				; show the help screen
B354: CD74B4   [17]     	call	clssavescr		; clear screen saving the drawing
B357: 210C18   [27]     	ld	hl,0x180c		; get text VRAM position
B35A: CD34C3   [44]     	call	drawlogosmall	; draw a small MASCIISDRAWX logo
B35D: DD21E0C5 [14]     lshh2:ld	ix,hlptxt		; get start pos of help page text indexes
B361: 0601     [21]     	ld	b,0x01		; reset page counter (not 0 because DJNZ)
B363: C5       [11]     lshh1:push	bc			; save page counter
B364: CD5601   [28]     	call	kilbuf		; clear keyboard buffer
                        					; clear screen from logo down
B367: 3E20     [35]     	ld	a,0x20		; get space char
B369: 01C002   [45]     	ld	bc,0x2c0		; get amount to clear
B36C: 214018   [55]     	ld	hl,0x1840		; get initial position to clear
                        					; show screens
B36F: CD5600   [72]     	call	filvrm		; fill area with spaces
B372: DD7E00   [91]     	ld	a,(ix)		; get low byte of content of text index
B375: 5F       [95]     	ld	e,a			; put in E
B376: DD7E01   [114]    	ld	a,(ix+1)		; get high byte of content of text index
B379: 57       [118]    	ld	d,a			; put in D
B37A: 214018   [128]    	ld	hl,0x1840		; get VRAM position
B37D: CD28B3   [145]    	call	writetext		; write text
B380: C1       [155]    	pop	bc			; restore page counter
B381: CD9F00   [172]    	call	chget			; wait for a character
B384: FE1C     [179]    	cp	0x1c			; is right arrow?
B386: 200C     [186|191]	jr	nz,sshh1		; if not, skip ahead
B388: DD23     [196]    	inc	ix			; increment help page text index twice
B38A: DD23     [206]    	inc	ix			;
B38C: 04       [210]    	inc	b			; increment counter
B38D: 78       [214]    	ld	a,b			; put in A
B38E: FE0A     [221]    	cp	0x0a			; is over the last page (EDIT)
B390: 28CB     [228|233]	jr	z,lshh2		; it it is, loop back to restart
B392: 18CF     [240]    	jr	lshh1			; loop to next page
B394: FE1D     [ 7]     sshh1:cp	0x1d			; is key left arrow?
B396: 200E     [14|19]  	jr	nz,sshh2		; if not, skip ahead
B398: DD2B     [24]     	dec	ix			; decrement help page text index twice
B39A: DD2B     [34]     	dec	ix			;
B39C: 10C5     [42|47]  	djnz	lshh1			; dec counter, if !< 0, loop to next screen
B39E: 0609     [ 7]     sshh3:ld	b,0x09		; put last page on counter (EDIT)
B3A0: DD21F0C5 [21]     	ld	ix,hlptxt+16	; get last help page text index (EDIT)
B3A4: 18BD     [33]     	jr	lshh1			; loop to next page
B3A6: FE1E     [ 7]     sshh2:cp	0x1e			; is key up arrow?
B3A8: 28B3     [14|19]  	jr	z,lshh2		; if so, loop back to restart
B3AA: FE1F     [21]     	cp	0x1f			; is key down arrow?
B3AC: 28F0     [28|33]  	jr	z,sshh3		; if so, loop back to last page
B3AE: CD8DB4   [45]     	call	clsrestscr		; restore drawing
B3B1: C9       [55]     	ret
                        
                        ; ------------------REQUESTERS
                        
B3B2:                   areyousure:				; make an "are you sure" requester and process answer
                        					; SURE text is put centered two rows down from label pos
                        					; input: DE=RAM label address,HL=VRAm label pos
B3B2: E5       [11]     	push	hl			; save text VRAM pos
B3B3: D5       [22]     	push	de			; save text RAM pos
B3B4: CD74B4   [39]     	call	clssavescr		; generate a standard background screen
B3B7: 210C18   [49]     	ld	hl,0x180c		; get text VRAM position
B3BA: CD34C3   [66]     	call	drawlogosmall	; draw a small MASCIISDRAWX logo
B3BD: D1       [76]     	pop	de			; restore text VRAM pos
B3BE: E1       [86]     	pop	hl			; restore text RAM pos
B3BF: CD28B3   [103]    	call	writetext		; write it
B3C2: 7D       [107]    	ld	a,l			; get VRAM text position low byte
B3C3: E6F0     [114]    	and	0b11110000		; round to decimal place
B3C5: 6F       [118]    	ld	l,a			; put back on VRAM text position
B3C6: 114900   [128]    	ld	de,0x49		; down 2 rows plus 9 column position
B3C9: 19       [139]    	add	hl,de			; add to VRAM text position
B3CA: 11D1C5   [149]    	ld	de,textsure		; get the SURE text
B3CD: CD28B3   [166]    	call	writetext		; write it
B3D0: CD5601   [183]    	call	kilbuf		; erase keyboard buffer
B3D3: CD9F00   [200]    	call	chget			; get a key press
B3D6: FE0D     [207]    	cp	0x0d			; is it ENTER?
B3D8: 280A     [214|219]	jr	z,says1		; if so, skip next
B3DA: FE20     [221]    	cp	0x20			; is it SPACE?
B3DC: 2806     [228|233]	jr	z,says1		; if so, skip next
B3DE: FE59     [235]    	cp	0x59			; is it "Y"?
B3E0: 2802     [242|247]	jr	z,says1		; if so, skip next
B3E2: FE79     [249]    	cp	0x79			; is it "y"?
B3E4: F5       [11]     says1:push	af			; save answer
B3E5: CD8DB4   [28]     	call	clsrestscr		; cancel the standard background screen
B3E8: F1       [38]     	pop	af			; restore answer
B3E9: C9       [48]     	ret
                        
B3EA:                   getrequlook:			; save drawing and get the requester look
B3EA: 3AEBF3   [13]     	ld	a,(BDRCLR)		; get border color
B3ED: 3266C4   [26]     	ld	(scrat+5),a		; save border color bkp
                        					; save drawing patterns on VRAM buffer
B3F0: 210801   [36]     	ld	hl,0x0108		; VRAM position from - from ! to ~
B3F3: 110028   [46]     	ld	de,VRBUF5		; VRAM position
B3F6: 014803   [56]     	ld	bc,0x0348		; length
B3F9: CD0BC3   [73]     	call	streamvv		; copy
                        					; save drawing color on VRAM buffer
B3FC: 210420   [83]     	ld	hl,0x2004		; VRAM position from
B3FF: 110030   [93]     	ld	de,VRBUF6		; VRAM position to
B402: 010D00   [103]    	ld	bc,0x000d		; length
B405: CD0BC3   [120]    	call	streamvv		; copy
                        					; copy interface font from RAM to VRAM
B408: 3E00     [127]    	ld	a,0x00		; make space character blank
B40A: 210001   [137]    	ld	hl,0x0100		; VRAM position to copy
B40D: 010800   [147]    	ld	bc,0x08		; length
B410: CD5600   [164]    	call	filvrm		; copy
B413: 219CCE   [174]    	ld	hl,fontint1		; font RAM position
B416: 110801   [184]    	ld	de,0x0108		; VRAM position to copy - ! to `
B419: 01FF01   [194]    	ld	bc,0x01ff		; length
B41C: CD5C00   [211]    	call	ldirvm		; copy
B41F: 219CCF   [221]    	ld	hl,fontint2		; font RAM position
B422: 110803   [231]    	ld	de,0x0308		; VRAM position to copy - A to Z
B425: 01D000   [241]    	ld	bc,0x00d0		; length
B428: CD5C00   [258]    	call	ldirvm		; copy
B42B: 219CD0   [268]    	ld	hl,fontint3		; font RAM position
B42E: 11D803   [278]    	ld	de,0x03d8		; VRAM position to copy - { to ~
B431: 016800   [288]    	ld	bc,0x0068		; length
B434: CD5C00   [305]    	call	ldirvm		; copy
                        					; assign color
B437: 3A64C4   [318]    	ld	a,(scrat+3)		; color to copy
B43A: 210420   [328]    	ld	hl,0x2004		; VRAM position to copy
B43D: 010D00   [338]    	ld	bc,0x000d		; length
B440: CD5600   [355]    	call	filvrm		; copy
B443: 3E1E     [362]    	ld	a,0x1e		; color to copy
B445: 210C20   [372]    	ld	hl,0x200c		; VRAM position to copy
B448: 010400   [382]    	ld	bc,0x0004		; length
B44B: CD5600   [399]    	call	filvrm		; copy
B44E: 3A63C4   [412]    	ld	a,(scrat+2)		; get def border color
B451: CDD0C3   [429]    	call	chbordcolor		; change it
B454: C9       [439]    	ret
                        
B455:                   droprequlook:			; restore drawing look
                        					; restore font patterns
B455: 210028   [10]     	ld	hl,VRBUF5		; VRAM position from
B458: 110801   [20]     	ld	de,0x0108		; VRAM position to
B45B: 014803   [30]     	ld	bc,0x0348		; length
B45E: CD0BC3   [47]     	call	streamvv		; copy
                        					; restore color
B461: 210030   [57]     	ld	hl,VRBUF6		; RAM position from
B464: 110420   [67]     	ld	de,0x2004		; VRAM position to
B467: 010D00   [77]     	ld	bc,0x000d		; length
B46A: CD0BC3   [94]     	call	streamvv		; copy
                        
B46D: 3A66C4   [107]    	ld	a,(scrat+5)		; get saved border color
B470: CDD0C3   [124]    	call	chbordcolor		; change it
B473: C9       [134]    	ret
                        
B474:                   clssavescr:				; save drawing and show the standard screen
                        					; copy screen contents
B474: 210018   [10]     	ld	hl,0x1800		; VRAM position from
B477: 110014   [20]     	ld	de,VRBUF4		; VRAM position to
B47A: 010003   [30]     	ld	bc,0x0300		; length
B47D: CD0BC3   [47]     	call	streamvv		; copy
                        					; create requester
B480: CDC300   [64]     	call	cls			; clear the screen
B483: CD9DC3   [81]     	call	hidecur		; hide cursor
B486: CDA6C3   [98]     	call	hidecharcur		; hide the character cursors
                        
B489: CDEAB3   [115]    	call	getrequlook		; get requ look and save original to VRAM
B48C: C9       [125]    	ret
                        
B48D:                   clsrestscr:				; drop standard screen and restore drawing
B48D: AF       [ 4]     	xor	a			; CLS needs Z reseted
B48E: CDC300   [21]     	call	cls			; clear the screen
B491: CD55B4   [38]     	call	droprequlook	; restore original look
                        					; restore screen contents
B494: 210014   [48]     	ld	hl,VRBUF4		; VRAM position from
B497: 110018   [58]     	ld	de,0x1800		; VRAM position to
B49A: 010003   [68]     	ld	bc,0x0300		; length
B49D: CD0BC3   [85]     	call	streamvv		; copy
B4A0: C9       [95]     	ret
                        
                        ; ------------------CHARACTER
                        
B4A1:                   drawchar:				; draw a character on the screen
B4A1: 2A2DC4   [16]     	ld	hl,(curat)		; get x,y (read bytes pos inverted)
B4A4: CD10C4   [33]     	call	vrampos		; get VRAM position
B4A7: 3A33C4   [46]     	ld	a,(curat+6)		; get current character
B4AA: CDFEC3   [63]     	call	wrtvrms		; write to VRAM safe
B4AD: C9       [73]     	ret
                        
B4AE:                   erasechar:				; erase a character on the screen
B4AE: 2A2DC4   [16]     	ld	hl,(curat)		; get x,y (read bytes pos inverted)
B4B1: CD10C4   [33]     	call	vrampos		; get VRAM position
B4B4: 3A35C4   [46]     	ld	a,(curat+8)		; get current character
B4B7: CDFEC3   [63]     	call	wrtvrms		; write to VRAM safe
B4BA: C9       [73]     	ret
                        
B4BB:                   rollchar:				; choose a current character
B4BB: 3A33C4   [13]     	ld	a,(curat+6)		; get the current character from variable
B4BE: 80       [17]     	add	a,b			; add offset
B4BF: 3233C4   [30]     	ld	(curat+6),a		; put back at variable
B4C2: CD1CB5   [47]     	call	getcharshape	; put character shape on sprite
B4C5: CD2DB5   [64]     	call	getcharcolor	; put character color on sprite
B4C8: CD5601   [81]     	call	kilbuf		; clear keyboard buffer
B4CB: C9       [91]     	ret
                        
B4CC:                   pickchar:				; get character under the cursor
B4CC: CDF4C3   [17]     	call	checkcurspos	; get cursor pos and check if is inside screen
B4CF: D8       [22|28]  	ret	c			; return if not
B4D0: CD4A00   [39]     	call	rdvrm			; read VRAM from position
B4D3: 3233C4   [52]     	ld	(curat+6),a		; put in current character variable
B4D6: CD1CB5   [69]     	call	getcharshape	; put character shape on sprite
B4D9: CD2DB5   [86]     	call	getcharcolor	; put character color on sprite
B4DC: CD5601   [103]    	call	kilbuf		; clear keyboard buffer
B4DF: C9       [113]    	ret		
                        
                        ; ------------------CURSOR
                        
B4E0:                   drawcsr:				; draw the cursor sprite
B4E0: 2A72C4   [16]     	ld	hl,(spcursor+6)	; cursor VRAM pos y address
B4E3: 3A2DC4   [29]     	ld	a,(curat)		; get RAM pos y
B4E6: 3D       [33]     	dec	a			; adjust for offset
B4E7: CD4D00   [50]     	call	wrtvrm		; write pos y to VRAM
B4EA: 23       [56]     	inc	hl			; move to VRAM attibute pos x
B4EB: 3A2EC4   [69]     	ld	a,(curat+1)		; get pos x
B4EE: CD4D00   [86]     	call	wrtvrm		; write pos x to VRAM
B4F1: C9       [96]     	ret
                        
B4F2:                   drawchcsr:				; draw the character cursor sprites
B4F2: 3A2DC4   [13]     	ld	a,(curat)		; get pos y
B4F5: C604     [20]     	add	4			; offset cursor
B4F7: E6F8     [27]     	and	0b11111000		; step by 8 increments
B4F9: 3D       [31]     	dec	a			; adjust for y sprite offset
B4FA: 2A1CC5   [47]     	ld	hl,(spcharac+6)	; character cursor VRAM attribute pos y
B4FD: CD4D00   [64]     	call	wrtvrm		; write pos y to VRAM
B500: 2A2DC5   [80]     	ld	hl,(spbckgrd+6)	; background cursor VRAM attribute pos y
B503: CD4D00   [97]     	call	wrtvrm		; write pos y to VRAM
                        
B506: 3A2EC4   [110]    	ld	a,(curat+1)		; get pos x
B509: C604     [117]    	add	4			; offset cursor
B50B: E6F8     [124]    	and	0b11111000		; step by 8 increments
B50D: 2A1CC5   [140]    	ld	hl,(spcharac+6)	; character cursor VRAM attribute pos y
B510: 23       [146]    	inc	hl			; inc to pos x
B511: CD4D00   [163]    	call	wrtvrm		; write pos y to VRAM
B514: 2A2DC5   [179]    	ld	hl,(spbckgrd+6)	; character cursor VRAM attribute pos y
B517: 23       [185]    	inc	hl			; inc to pos x
B518: CD4D00   [202]    	call	wrtvrm		; write pos y to VRAM
B51B: C9       [212]    	ret
                        
B51C:                   getcharshape:			; put char pattern value to char cursor
                        					; input: A=character
B51C: 2600     [ 7]     	ld	h,0x00		; put current character value in HL
B51E: 6F       [11]     	ld	l,a			; idem
B51F: 29       [22]     	add	hl,hl			; multiply by 8 to get VRAM pos
B520: 29       [33]     	add	hl,hl			; idem
B521: 29       [44]     	add	hl,hl			; idem
B522: ED5B1AC5 [64]     	ld	de,(spcharac+4)	; character sprite RAM pattern
B526: 010800   [74]     	ld	bc,0x08		; 8 bytes of data to copy
B529: CD0BC3   [91]     	call	streamvv		; copy
B52C: C9       [101]    	ret
                        
B52D:                   getcharcolor:			; put char color value to char and BG cursor
                        					; input: A=character
B52D: CDA9BE   [17]     	call	getcolorfrchr	; get character color
                        					; put on the background sprite
B530: F5       [28]     	push	af			; save color
B531: E60F     [35]     	and	0b00001111		; discard higher than 15
B533: 2A2DC5   [51]     	ld	hl,(spbckgrd+6)	; background cursor VRAM attribute pos y
B536: 23       [57]     	inc	hl			; inc to color
B537: 23       [63]     	inc	hl			;
B538: 23       [69]     	inc	hl			;
B539: CD4D00   [86]     	call	wrtvrm		; apply
                        					; put on the character sprite
B53C: F1       [96]     	pop	af			; restore color
B53D: 0F       [100]    	rrca				; send bits to lower nibble
B53E: 0F       [104]    	rrca				; send bits to lower nibble
B53F: 0F       [108]    	rrca				; send bits to lower nibble
B540: 0F       [112]    	rrca				; send bits to lower nibble
B541: E60F     [119]    	and	0b00001111		; discard higher than 15
B543: 2A1CC5   [135]    	ld	hl,(spcharac+6)	; character cursor VRAM attribute pos y
B546: 23       [141]    	inc	hl			; inc to color
B547: 23       [147]    	inc	hl			;
B548: 23       [153]    	inc	hl			;
B549: CD4D00   [170]    	call	wrtvrm		; apply
B54C: C9       [180]    	ret
                        
B54D:                   cursorcolor:			; change the cursor color
B54D: 3A36C4   [13]     	ld	a,(curat+9)		; get cursor color
B550: 80       [17]     	add	b			; add/sub color
B551: E60F     [24]     	and	0b00001111		; discard high nibble
B553: 3236C4   [37]     	ld	(curat+9),a		; save cursor color
B556: 210DC5   [47]     	ld	hl,splastcu+8	; get position of last cursor number
B559: 46       [54]     	ld	b,(hl)		; put in counter
B55A: 1172C4   [64]     	ld	de,spcursor+6	; get RAM pos for 1st sprite attribute table
B55D: 1A       [ 7]     lcuco:ld	a,(de)		; get low byte
B55E: 6F       [11]     	ld	l,a			; put in L
B55F: 13       [17]     	inc	de			; go to the high byte
B560: 1A       [24]     	ld	a,(de)		; get high byte
B561: 67       [28]     	ld	h,a			; put in H
B562: 23       [34]     	inc	hl			; move HL to color attribute
B563: 23       [40]     	inc	hl			; idem
B564: 23       [46]     	inc	hl			; idem
B565: 3A36C4   [59]     	ld	a,(curat+9)		; get cursor color
B568: CD4D00   [76]     	call	wrtvrm		; send to VRAM color attribute
B56B: 3E10     [83]     	ld	a,0x10		; amount to advance RAM addresses
B56D: CDE3C3   [100]    	call	add8to16		; advance to next sprite RAM attribute table pos
B570: 10EB     [108|113]	djnz	lcuco			; decrement counter, if not 0, loop
B572: CD5601   [125]    	call	kilbuf		; clear keyboard buffer
B575: C9       [135]    	ret
                        
                        ; ------------------SCREEN
                        
B576:                   undolast:				; undo last action
B576: 21000C   [10]     	ld	hl,VRBUF2		; undo buffer address
B579: 110018   [20]     	ld	de,0x1800		; get screen start address
B57C: 010003   [30]     	ld	bc,0x300		; get amount to copy
B57F: CDEDC2   [47]     	call	swapvv		; swap screen with undo buffer
B582: C9       [57]     	ret
                        
B583:                   swapbuffers:			; swap between 2 screens
B583: 210018   [10]     	ld	hl,0x1800		; screen start pos
B586: 110010   [20]     	ld	de,VRBUF3		; swap screen start pos
B589: 010003   [30]     	ld	bc,0x300		; amount to copy
B58C: CDEDC2   [47]     	call	swapvv		; swap screens
B58F: C9       [57]     	ret
                        
B590:                   cyclebordcol:			; cycle the border color
                        					; input: B=0x00 or 0xff
B590: 3AEBF3   [13]     	ld	a,(BDRCLR)		; get the current border color
B593: 80       [17]     	add	b			; add or subtract
B594: CDD0C3   [34]     	call	chbordcolor		; change the color
B597: CD5601   [51]     	call	kilbuf		; clear keyboard buffer
B59A: C9       [61]     	ret
                        
B59B:                   clearscr:				; clear the screen
B59B: 11AAC5   [10]     	ld	de,textclear	; text message address
B59E: 214A19   [20]     	ld	hl,0x194a		; text VRAM position
B5A1: CDB2B3   [37]     	call	areyousure		; call confirmation
B5A4: C0       [42|48]  	ret	nz			; if not, return
B5A5: CDC4C2   [59]     	call	setundo		; copy screen for undo
B5A8: CDC300   [76]     	call	cls			; clear the screen
B5AB: CD5601   [93]     	call	kilbuf		; clear keyboard buffer
B5AE: C9       [103]    	ret
                        
B5AF:                   clearscrchar:			; clear the screen with the current character
B5AF: 11AAC5   [10]     	ld	de,textclear	; text message address
B5B2: 214A19   [20]     	ld	hl,0x194a		; text VRAM position
B5B5: CDB2B3   [37]     	call	areyousure		; call confirmation
B5B8: C0       [42|48]  	ret	nz			; if not, return
B5B9: CDC4C2   [59]     	call	setundo		; copy screen for undo
B5BC: 3A33C4   [72]     	ld	a,(curat+6)		; get current character from variable
B5BF: 010003   [82]     	ld	bc,0x300		; get the screen VRAM size
B5C2: 210018   [92]     	ld	hl,0x1800		; get the screen VRAM start address
B5C5: CD5600   [109]    	call	filvrm		; fill the area with the character
B5C8: CD5601   [126]    	call	kilbuf		; clear keyboard buffer
B5CB: C9       [136]    	ret
                        
B5CC:                   clearscrinit:			; initialize the screen and tables
B5CC: 11B7C5   [10]     	ld	de,textreset	; text message address
B5CF: 214A19   [20]     	ld	hl,0x194a		; text VRAM position
B5D2: CDB2B3   [37]     	call	areyousure		; call confirmation
B5D5: C0       [42|48]  	ret	nz			; if not, return
B5D6: CD6F00   [59]     	call	init32		; initialize the screen
B5D9: CD8FB0   [76]     	call	initsprites		; initialize the sprites
B5DC: 3A33C4   [89]     	ld	a,(curat+6)		; get current character
B5DF: CD1CB5   [106]    	call	getcharshape	; put character shape on sprite
B5E2: CD2DB5   [123]    	call	getcharcolor	; put character color on sprite
B5E5: CD5601   [140]    	call	kilbuf		; clear keyboard buffer
B5E8: C9       [150]    	ret
                        
B5E9:                   scrollup:				; scroll the screen up
B5E9: CDD4C2   [17]     	call	copyscrtobuf2	; copy whole screen to buffer 2
                        					; get buffer minus first row and put on VRAM
B5EC: 110018   [27]     	ld	de,0x1800		; initial VRAM pos
B5EF: 2168D4   [37]     	ld	hl,buffer2+0x20	; the buffer to use
B5F2: 01E002   [47]     	ld	bc,0x02e0		; the whole screen
B5F5: CD5C00   [64]     	call	ldirvm		; put RAM on VRAM
                        					; get first buffer row and put on last VRAM row
B5F8: 11E01A   [74]     	ld	de,0x1ae0		; initial VRAM pos
B5FB: 2148D4   [84]     	ld	hl,buffer2		; pos after last RAM row
B5FE: 012000   [94]     	ld	bc,0x0020		; amount to copy. one row
B601: CD5C00   [111]    	call	ldirvm		; put VRAM on RAM
B604: CD5601   [128]    	call	kilbuf		; clear keyboard buffer
B607: C9       [138]    	ret
                        
B608:                   scrolldown:				; scroll the screen down
B608: CDD4C2   [17]     	call	copyscrtobuf2	; copy whole screen to buffer 2
                        					; get buffer minus last row and put on VRAM second row
B60B: 112018   [27]     	ld	de,0x1820		; initial VRAM pos
B60E: 2148D4   [37]     	ld	hl,buffer2		; the buffer to use
B611: 01E002   [47]     	ld	bc,0x02e0		; the whole screen
B614: CD5C00   [64]     	call	ldirvm		; put RAM on VRAM
                        					; get last buffer row and put on first VRAM row
B617: 110018   [74]     	ld	de,0x1800		; initial VRAM pos
B61A: 2128D7   [84]     	ld	hl,buffer2+0x02e0	; pos after last RAM row
B61D: 012000   [94]     	ld	bc,0x0020		; amount to copy. one row
B620: CD5C00   [111]    	call	ldirvm		; put VRAM on RAM
B623: CD5601   [128]    	call	kilbuf		; clear keyboard buffer
B626: C9       [138]    	ret
                        
B627:                   scrollright:			; scroll the screen right
B627: CDD4C2   [17]     	call	copyscrtobuf2	; copy whole screen to buffer 2
                        					; copy to start of VRAM screen skipping first byte
B62A: 110118   [27]     	ld	de,0x1801		; initial VRAM pos skipping 1 byte
B62D: 2148D4   [37]     	ld	hl,buffer2		; buffer to use
B630: 01FF02   [47]     	ld	bc,0x02ff		; whole screen minus 1 byte
B633: CD5C00   [64]     	call	ldirvm		; put RAM on VRAM
                        					; raise the first column 1 row up
B636: 0618     [71]     	ld	b,0x18		; put amount of rows in counter
B638: 210018   [81]     	ld	hl,0x1800		; initial VRAM pos. top of first column
B63B: 1167D4   [91]     	ld	de,buffer2+0x1f	; the top of last column on RAM
B63E: CD63B6   [108]    	call	fixscrollcol	; put on first VRAM column and move up
B641: CD5601   [125]    	call	kilbuf		; clear keyboard buffer
B644: C9       [135]    	ret
                        
B645:                   scrollleft:				; scroll the screen left
B645: CDD4C2   [17]     	call	copyscrtobuf2	; copy whole screen to buffer 2
                        					; copy to start of VRAM screen minus first byte from RAM
B648: 110018   [27]     	ld	de,0x1800		; initial VRAM pos
B64B: 2149D4   [37]     	ld	hl,buffer2+0x01	; buffer to use minus first byte
B64E: 01FF02   [47]     	ld	bc,0x02ff		; whole screen minus 1 byte
B651: CD5C00   [64]     	call	ldirvm		; put RAM on VRAM
                        					; raise the last column 1 row up
B654: 0618     [71]     	ld	b,0x18		; put amount of rows in counter
B656: 211F18   [81]     	ld	hl,0x181f		; initial VRAM pos. top of last column
B659: 1148D4   [91]     	ld	de,buffer2		; top of first column on RAM
B65C: CD63B6   [108]    	call	fixscrollcol	; put on last VRAM column and move up
B65F: CD5601   [125]    	call	kilbuf		; clear keyboard buffer
B662: C9       [135]    	ret
                        
B663:                   fixscrollcol:			; raise a screen column 1 row up
B663: 1A       [ 7]     	ld	a,(de)		; get character from buffer position
B664: CD4D00   [24]     	call	wrtvrm		; write to VRAM
B667: C5       [35]     	push	bc			; save rows counter
B668: 012000   [45]     	ld	bc,0x20		; amount to move down one line
B66B: 09       [56]     	add	hl,bc			; move down VRAM address
B66C: EB       [60]     	ex	de,hl			; exchange RAM<>VRAM
B66D: 09       [71]     	add	hl,bc			; move down RAM address
B66E: EB       [75]     	ex	de,hl			; exchange back RAM<>VRAM
B66F: C1       [85]     	pop	bc			; restore rows counter
B670: 10F1     [93|98]  	djnz	fixscrollcol	; decrement, if not 0, loop
B672: C9       [103]    	ret
                        
B673:                   flipscrvert:			; flip the screen vertically
B673: C5       [11]     	push	bc			; save flip type
B674: CDD4C2   [28]     	call	copyscrtobuf2	; copy whole screen to buffer 2
                        					; copy rows exchanging top with bottom
B677: 21E01A   [38]     	ld	hl,0x1ae0		; initial VRAM pos - last row
B67A: 1148D4   [48]     	ld	de,buffer2		; buffer to use
B67D: 011820   [58]     	ld	bc,0x2018		; counters: B=&h20cols,C=&h18rows
B680: 1A       [ 7]     lfsv1:ld	a,(de)		; get character from buffer
B681: CD4D00   [24]     	call	wrtvrm		; put on VRAM
B684: 13       [30]     	inc	de			; increment 1 RAM column
B685: 23       [36]     	inc	hl			; increment 1 VRAM column
B686: 10F8     [44|49]  	djnz	lfsv1			; decrement counter, if not 0, loop 
B688: 0620     [51]     	ld	b,0x20		; restore cols counter
B68A: C5       [62]     	push	bc			; save counters
B68B: 014000   [72]     	ld	bc,0x40		; amount to go to the start of above row
B68E: ED42     [87]     	sbc	hl,bc			; adjust VRAM pointer
B690: C1       [97]     	pop	bc			; restore counters
B691: 0D       [101]    	dec	c			; decrement row counter
B692: 20EC     [108|113]	jr	nz,lfsv1		; if not 0, loop
                        					; test flip type
B694: C1       [118]    	pop	bc			; restore flip type
B695: 78       [122]    	ld	a,b			; put in A
B696: FE00     [129]    	cp	0x00			; compare to don't flip patterns type
B698: 2822     [136|141]	jr	z,sfsv1		; if match, skip flipping patterns
                        					; flip patterns
B69A: 3EFF     [143]    	ld	a,0xff		; get last character index
B69C: F5       [11]     lfsv2:push	af			; save it
B69D: CDB6BE   [28]     	call	getpatternad	; get its pattern address
B6A0: D5       [39]     	push	de			; save pattern address
B6A1: 0608     [46]     	ld	b,0x08		; set rows/ bytes counter
B6A3: 1140C4   [56]     	ld	de,edthelpch+7	; get the temp char last (7th) pattern address
B6A6: CD4A00   [17]     lfsv3:call	rdvrm			; read the first editing char pattern address
B6A9: 12       [24]     	ld	(de),a		; put first editing byte on last temp byte
B6AA: 23       [30]     	inc	hl			; increment editing
B6AB: 1B       [36]     	dec	de			; decrement temp
B6AC: 10F8     [44|49]  	djnz	lfsv3			; do until character finished
B6AE: 2139C4   [54]     	ld	hl,edthelpch	; get address of temp character
B6B1: D1       [64]     	pop	de			; restore address of editing char pattern
B6B2: 010800   [74]     	ld	bc,0x08		; set the length to all character
B6B5: CD5C00   [91]     	call	ldirvm		; copy temp character to editing character
B6B8: F1       [101]    	pop	af			; restore character index
B6B9: 3D       [105]    	dec	a			; decrement it
B6BA: 20E0     [112|117]	jr	nz,lfsv2		; if not 0, loop
B6BC: CD5601   [17]     sfsv1:call	kilbuf		; clear keyboard buffer
B6BF: C9       [27]     	ret
                        
B6C0:                   flipscrhorz:			; flip the screen horizontally
B6C0: C5       [11]     	push	bc			; save flip type
B6C1: CDD4C2   [28]     	call	copyscrtobuf2	; copy whole screen to buffer 2
                        					; copy columns exchanging left with right
B6C4: 012018   [38]     	ld	bc,0x1820		; counters: B=&h20cols,C=&h18rows
B6C7: 211F18   [48]     	ld	hl,0x181f		; initial VRAM pos. top of last column
B6CA: 1148D4   [58]     	ld	de,buffer2		; top of first column on RAM
B6CD: 1A       [ 7]     lfsh1:ld	a,(de)		; get character from buffer position
B6CE: CD4D00   [24]     	call	wrtvrm		; write to VRAM
B6D1: C5       [35]     	push	bc			; save counters
B6D2: 012000   [45]     	ld	bc,0x20		; amount to back one row up
B6D5: 09       [56]     	add	hl,bc			; move down VRAM address
B6D6: EB       [60]     	ex	de,hl			; exchange RAM<>VRAM
B6D7: 09       [71]     	add	hl,bc			; move down RAM address
B6D8: EB       [75]     	ex	de,hl			; exchange back RAM<>VRAM
B6D9: C1       [85]     	pop	bc			; restore counters
B6DA: 10F1     [93|98]  	djnz	lfsh1			; decrement, if not 0, loop
B6DC: 0618     [100]    	ld	b,0x18		; restore rows counter
B6DE: C5       [111]    	push	bc			; save counters
B6DF: 010003   [121]    	ld	bc,0x300		; amount to move back to top of column
B6E2: ED42     [136]    	sbc	hl,bc			; move there
B6E4: 2B       [142]    	dec	hl			; move one column back
B6E5: EB       [146]    	ex	de,hl			; exchange RAM<>VRAM
B6E6: ED42     [161]    	sbc	hl,bc			; move back to top of column
B6E8: 23       [167]    	inc	hl			; advance one column
B6E9: EB       [171]    	ex	de,hl			; exchange back RAM<>VRAM
B6EA: C1       [181]    	pop	bc			; restore counters
B6EB: 0D       [185]    	dec	c			; decrement cols counter
B6EC: 20DF     [192|197]	jr	nz,lfsh1		; if not 0, loop
                        					; test flip type
B6EE: C1       [202]    	pop	bc			; restore flip type
B6EF: 78       [206]    	ld	a,b			; put in A
B6F0: FE00     [213]    	cp	0x00			; compare to don't flip patterns type
B6F2: 281A     [220|225]	jr	z,sssh1		; if match, skip flipping patterns
                        					; flip patterns
B6F4: 210000   [230]    	ld	hl,0x0000		; pattern address
B6F7: 110008   [240]    	ld	de,0x0800		; pattern length
B6FA: 0608     [ 7]     lssh2:ld	b,0x08		; columns/bits length
B6FC: CD4A00   [24]     	call	rdvrm			; read pattern
B6FF: 4F       [28]     	ld	c,a			; save to D
B700: CB11     [ 8]     lssh3:rl	c			; rotate its bits left and put on the carrier
B702: 1F       [12]     	rra				; put the carrier on the A right bit
B703: 10FB     [20|25]  	djnz	lssh3			; repeat until all columns/bits are done
B705: CD4D00   [37]     	call	wrtvrm		; write it back
B708: 23       [43]     	inc	hl			; go to next pattern byte
B709: 1B       [49]     	dec	de			; decrement rows/bytes counter
B70A: 7A       [53]     	ld	a,d			; put high byte in A
B70B: B3       [57]     	or	e			; compare with C
B70C: 20EC     [64|69]  	jr	nz,lssh2		; do until all rows/bytes are done
B70E: CD5601   [17]     sssh1:call	kilbuf		; clear keyboard buffer
B711: C9       [27]     	ret
                        
                        ; ------------------CONTROLS
                        
B712:                   checktrigger:			; check mouse button 1 or space
                        					; output: NZ if pressed
B712: 3AE8F3   [13]     	ld	a,(TRGFLG)		; get trigger flags
B715: E611     [20]     	and	0b00010001		; mask unwanted bite
B717: EE11     [27]     	xor	0b00010001		; compare if TRIG or SPC pressed
B719: C0       [32|38]  	ret	nz			; if pressed, return
B71A: 2109B0   [42]     	ld	hl,flags+1		; if not. reset trigger flag
B71D: CBBE     [57]     	res	7,(hl)		; 
B71F: C9       [67]     	ret
                        
B720:                   checkbutton2:			; check mouse button 2
                        					; output: NZ if pressed
B720: 3AE8F3   [13]     	ld	a,(TRGFLG)		; get trigger flags
B723: E620     [20]     	and	0b00100000		; mask unwanted bite
B725: EE20     [27]     	xor	0b00100000		; compare if TRIG2 pressed
B727: C9       [37]     	ret
                        
B728:                   waittrgrls:				; wait until trigger release
B728: CD12B7   [17]     	call	checktrigger	; check trigger
B72B: 20FB     [24|29]  	jr	nz,waittrgrls	; if pressed, loop
B72D: CD20B7   [41]     	call	checkbutton2	; check trigger
B730: 20F6     [48|53]  	jr	nz,waittrgrls	; if pressed, loop
B732: C9       [58]     	ret
                        
B733:                   movecursor:				; move cursor with the mouse
B733: 3A2EC4   [13]     	ld	a,(curat+1)		; get sprite pos x
B736: 94       [17]     	sub	h			; subtract from mouse offset
B737: 322EC4   [30]     	ld	(curat+1),a		; save sprite pos x
                        
B73A: 3A2DC4   [43]     	ld	a,(curat)		; get sprite pos y
B73D: 95       [47]     	sub	l 			; subtract from mouse offset
B73E: CD60B7   [64]     	call	fixycoord		; prevent access to higher than 191 y screen pos
B741: 322DC4   [77]     	ld	(curat),a		; save sprite pos y
B744: C9       [87]     	ret
                        
B745:                   movcurhor:				; move the cursor horizontally with the keyboard
B745: 212EC4   [10]     	ld	hl,curat+1		; get cursor x pos address
B748: 7E       [17]     	ld	a,(hl)		; get cursor position
B749: E6F8     [24]     	and	a,0b11111000	; step by 8 increments
B74B: 80       [28]     	add	a,b			; add movement offset
B74C: 77       [35]     	ld	(hl),a		; save cursor position
B74D: CD5601   [52]     	call	kilbuf		; clear keyboard buffer
B750: C9       [62]     	ret
                        
B751:                   movcurver:				; move the cursor vertically with the keyboard
B751: 212DC4   [10]     	ld	hl,curat		; get cursor y pos address
B754: 7E       [17]     	ld	a,(hl)		; get cursor position
B755: E6F8     [24]     	and	a,0b11111000	; step by 8 increments
B757: 80       [28]     	add	a,b			; add movement offset
B758: CD60B7   [45]     	call	fixycoord		; prevent access to higher than 191 y screen pos
B75B: 77       [52]     	ld	(hl),a		; save cursor position
B75C: CD5601   [69]     	call	kilbuf		; clear keyboard buffer
B75F: C9       [79]     	ret
                        
B760:                   fixycoord:				; prevent access to higher than 191 y screen pos
B760: FEBC     [ 7]     	cp	0xbc			; compare with screen bottom (192-4)
B762: D8       [12|18]  	ret	c			; if less, its inside screen, return
B763: FEC1     [19]     	cp	0xc1			; compare with 192, past screen bottom
B765: 3003     [26|31]  	jr	nc,sfycoo		; if bigger, skip
B767: 3EFD     [33]     	ld	a,0xfd		; if not put on screen top (0-4)
B769: C9       [43]     	ret				; and return
B76A: FEFC     [ 7]     sfycoo:cp	0xfc			; compare with screen top (0-4)
B76C: D0       [12|18]  	ret	nc			; if bigger, still inside screen, return
B76D: 3EBB     [19]     	ld	a,0xbb		; if not. put on screen bottom
B76F: C9       [29]     	ret
                        
B770:                   getmouse: 				; Read the mouse (found on the interwebs)
                        					; Input: D/E=mouse number Output: H=X-offset, L=Y-offset
                        					; Note that the routine will output H=L=255 if no mouse is present!
B770: 111093   [10]     	ld	de,0x9310		; mouse 1
B773: CDB0B7   [27]     	call	gtofst		; Read bit 7-4 of the x-offset
B776: E60F     [34]     	and	0xf
B778: 07       [38]     	rlca
B779: 07       [42]     	rlca
B77A: 07       [46]     	rlca
B77B: 07       [50]     	rlca
B77C: 4F       [54]     	ld	c,a
B77D: CDB0B7   [71]     	call	gtofst		; Read bit 3-0 of the x-offset
B780: E60F     [78]     	and	0xf
B782: B1       [82]     	or	c
B783: 67       [86]     	ld	h,a			; Store combined x-offset
B784: CDB0B7   [103]    	call	gtofst		; Read bit 7-4 of the y-offset
B787: E60F     [110]    	and	0xf
B789: 07       [114]    	rlca
B78A: 07       [118]    	rlca
B78B: 07       [122]    	rlca
B78C: 07       [126]    	rlca
B78D: 4F       [130]    	ld	c,a
B78E: CDB0B7   [147]    	call	gtofst		; Read bit 3-0 of the y-offset
B791: E60F     [154]    	and	0xf
B793: B1       [158]    	or	c
B794: 6F       [162]    	ld	l,a			; Store combined y-offset
                        					; filter random 15 pixels mouse jump
B795: 3E0F     [169]    	ld	a,15
B797: BC       [173]    	cp	h
B798: 2810     [180|185]	jr	z,sgtm1
B79A: 3EF0     [187]    	ld	a,240
B79C: BC       [191]    	cp	h
B79D: 280B     [198|203]	jr	z,sgtm1
B79F: 3E0F     [205]    	ld	a,15
B7A1: BD       [209]    	cp	l
B7A2: 2809     [216|221]	jr	z,sgtm2
B7A4: 3EF0     [223]    	ld	a,240
B7A6: BD       [227]    	cp	l
B7A7: 2804     [234|239]	jr	z,sgtm2
B7A9: C9       [244]    	ret
B7AA: 2600     [ 7]     sgtm1:ld	h,0
B7AC: C9       [17]     	ret
B7AD: 2E00     [ 7]     sgtm2:ld	l,0
B7AF: C9       [17]     	ret
                        
B7B0:                   gtofst:
B7B0: 3E0F     [ 7]     	ld	a,15            ; Read psg register 15 for mouse
B7B2: D3A0     [18]     	out	(0xa0),a
B7B4: 7A       [22]     	ld	a,d
B7B5: D3A1     [33]     	out	(0xa1),a
B7B7: AB       [37]     	xor	e
B7B8: 57       [41]     	ld	d,a
                        
B7B9: 3E0E     [48]     	ld	a,14
B7BB: D3A0     [59]     	out	(0xa0),a
B7BD: DBA2     [70]     	in	a,(0xa2)
B7BF: C9       [80]     	ret
                        #include "masciiRE.asm"		; rectangle operations
                        ; ------------------RECTANGLE OPERATIONS
                        
B7C0:                   preparerect:			; prepare to get a rectangle
B7C0: 78       [ 4]     	ld	a,b			; get the rectangle type
B7C1: 3267C4   [17]     	ld	(rectt),a		; save it
B7C4: CDF4C3   [34]     	call	checkcurspos	; check if cursor is inside the screen
B7C7: D8       [39|45]  	ret	c			; return if not
B7C8: CDC4B8   [56]     	call	preprectcurs	; prepare rectangle cursors
                        					; define y position to horizontal box cursors
                        					; * no DEC A y adjustment in rect routine to avoid going >0 *
B7CB: 212FC4   [66]     	ld	hl,curat+2		; get mem pos to y1
B7CE: 3A2DC4   [79]     	ld	a,(curat)		; get y
B7D1: C604     [86]     	add	4			; offset cursor
B7D3: E6F8     [93]     	and	0b11111000		; step by 8 increments
B7D5: 77       [100]    	ld	(hl),a		; save
                        					; define x position to vertical box cursors
B7D6: 2130C4   [110]    	ld	hl,curat+3		; get mem pos to x1
B7D9: 3A2EC4   [123]    	ld	a,(curat+1)		; get x
B7DC: C604     [130]    	add	4			; offset cursor
B7DE: E6F8     [137]    	and	0b11111000		; step by 8 increments
B7E0: 77       [144]    	ld	(hl),a		; copy x to x1
                        					; set flags
B7E1: 2108B0   [154]    	ld	hl,flags		; get flags byte
B7E4: CBE6     [169]    	set	4,(hl)		; set rectangle flag
B7E6: CBEE     [184]    	set	5,(hl)		; set disable gen input flag
B7E8: CD5601   [201]    	call	kilbuf		; clear keyboard buffer
B7EB: C9       [211]    	ret
                        
B7EC:                   changerect:				; change the box mode
B7EC: 3A67C4   [13]     	ld	a,(rectt)		; get the current box mode
B7EF: FE06     [20]     	cp	0x06			; is the paste box?
B7F1: 2807     [27|32]  	jr	z,schr1		; if so, skip
B7F3: 3C       [31]     	inc	a			; increment
B7F4: FE05     [38]     	cp	0x05			; is past last mode?
B7F6: 2002     [45|50]  	jr	nz,schr1		; if not, skip
B7F8: 3E00     [52]     	ld	a,0x00		; set the first box mode
B7FA: 3267C4   [13]     schr1:ld	(rectt),a		; assign box mode
B7FD: CDC4B8   [30]     	call	preprectcurs	; reconfigure cursors
B800: CD5601   [47]     	call	kilbuf		; clear keyboard buffer
B803: C9       [57]     	ret
                        
B804:                   showrectcurs:			; draw rectangle cursors on the screen
                        					; input: CURAT - cursor positions
                        					; * no DEC A y adjustment in rect routine to avoid going >0 *
B804: 3A2DC4   [13]     	ld	a,(curat)		; get pos y
B807: C604     [20]     	add	4			; offset cursor
B809: E6F8     [27]     	and	0b11111000		; step by 8 increments
B80B: 2AA5C4   [43]     	ld	hl,(spboxlin+6)	; sprite 3 VRAM attribute pos y
B80E: CD4D00   [60]     	call	wrtvrm		; write pos y to VRAM
B811: 2AB6C4   [76]     	ld	hl,(spboxadd+6)	; sprite 4 VRAM attribute pos y
B814: CD4D00   [93]     	call	wrtvrm		; write pos y to VRAM
                        
B817: 3A2EC4   [106]    	ld	a,(curat+1)		; get pos x
B81A: C604     [113]    	add	4			; offset cursor
B81C: E6F8     [120]    	and	0b11111000		; step by 8 increments
B81E: 2A94C4   [136]    	ld	hl,(spboxhol+6)	; sprite 2 VRAM attribute pos y
B821: 23       [142]    	inc	hl			; inc to pos x
B822: CD4D00   [159]    	call	wrtvrm		; write pos y to VRAM
B825: 2AB6C4   [175]    	ld	hl,(spboxadd+6)	; sprite 4 VRAM attribute pos y
B828: 23       [181]    	inc	hl			; inc topos x
B829: CD4D00   [198]    	call	wrtvrm		; write pos y to VRAM
                        
B82C: 3A2FC4   [211]    	ld	a,(curat+2)		; get pos y1
B82F: C604     [218]    	add	4			; offset cursor
B831: E6F8     [225]    	and	0b11111000		; step by 8 increments
B833: 2A83C4   [241]    	ld	hl,(spboxfil+6)	; sprite 1 VRAM attribute pos y
B836: CD4D00   [258]    	call	wrtvrm		; write pos y1 to VRAM
B839: 2A94C4   [274]    	ld	hl,(spboxhol+6)	; sprite 2 VRAM attribute pos y
B83C: CD4D00   [291]    	call	wrtvrm		; write pos y1 to VRAM
                        
B83F: 3A30C4   [304]    	ld	a,(curat+3)		; get pos x1
B842: C604     [311]    	add	4			; offset cursor
B844: E6F8     [318]    	and	0b11111000		; step by 8 increments
B846: 2A83C4   [334]    	ld	hl,(spboxfil+6)	; sprite 1 VRAM attribute pos y
B849: 23       [340]    	inc	hl			; inc to pos x
B84A: CD4D00   [357]    	call	wrtvrm		; write pos x1 to VRAM
B84D: 2AA5C4   [373]    	ld	hl,(spboxlin+6)	; sprite 3 VRAM attribute pos y
B850: 23       [379]    	inc	hl			; inc to pos x
B851: CD4D00   [396]    	call	wrtvrm		; write pos x1 to VRAM
B854: C9       [406]    	ret
                        
B855:                   activaterect:			; accept rectangle and prepare to draw
                        					; check if is out of screen
B855: CDF4C3   [17]     	call	checkcurspos	; check if cursor is inside screen
B858: D8       [22|28]  	ret	c			; return if not
                        					; adjust y position
                        					; * no DEC A y adjustment in rect routine to avoid going >0 *
B859: 3A2DC4   [35]     	ld	a,(curat)		; get y
B85C: 3231C4   [48]     	ld	(curat+4),a		; save copy
B85F: C604     [55]     	add	4			; offset cursor
B861: E6F8     [62]     	and	0b11111000		; step by 8 increments
B863: 322DC4   [75]     	ld	(curat),a		; save
                        					; adjust x position
B866: 3A2EC4   [88]     	ld	a,(curat+1)		; get x
B869: 3232C4   [101]    	ld	(curat+5),a		; save copy
B86C: C604     [108]    	add	4			; offset cursor
B86E: E6F8     [115]    	and	0b11111000		; step by 8 increments
B870: 322EC4   [128]    	ld	(curat+1),a		; save
                        
B873: CDC4C2   [145]    	call	setundo		; copy screen for undo
B876: CDECB8   [162]    	call	getvramrectpos	; convert x,y,x1,y1 (curat) to memory positions (RECTT)
                        
B879: 3A67C4   [175]    	ld	a,(rectt)		; get the rectangle type
B87C: FE01     [182]    	cp	0x01			; compare with 1 (filled box)
B87E: CC2CBA   [192|199]	call	z,drawboxhol
B881: 3A67C4   [205]    	ld	a,(rectt)		; get the rectangle type
B884: FE00     [212]    	cp	0x00			; compare with 0 (hollow box)
B886: CC0EBA   [222|229]	call	z,drawboxfil
B889: 3A67C4   [235]    	ld	a,(rectt)		; get the rectangle type
B88C: FE02     [242]    	cp	0x02			; compare with 2 (line box)
B88E: CC52BA   [252|259]	call	z,drawboxlin
B891: 3A67C4   [265]    	ld	a,(rectt)		; get the rectangle type
B894: FE03     [272]    	cp	0x03			; compare with 3 (line add box)
B896: CC52BA   [282|289]	call	z,drawboxlin
B899: 3A67C4   [295]    	ld	a,(rectt)		; get the rectangle type
B89C: FE04     [302]    	cp	0x04			; compare with 4 (line add box)
B89E: CCEBB9   [312|319]	call	z,drawboxchr
B8A1: 3A67C4   [325]    	ld	a,(rectt)		; get the rectangle type
B8A4: FE05     [332]    	cp	0x05			; compare with 5 (copy)
B8A6: CC57B9   [342|349]	call	z,getpastebox
                        
B8A9: 2A31C4   [358]    	ld	hl,(curat+4)	; get saved x,y cursor pos
B8AC: 222DC4   [374]    	ld	(curat),hl		; put on current variable
                        
B8AF: CDB6B8   [391]    	call	cancelrect		; cancel rectangle
B8B2: CD28B7   [408]    	call	waittrgrls		; wait for trigger release
B8B5: C9       [418]    	ret
                        
B8B6:                   cancelrect:				; cancel the rectangle
B8B6: CDB5C3   [17]     	call	hideboxcur		; hide box cursors
                        					; reset flags
B8B9: 2108B0   [27]     	ld	hl,flags		; get flags byte
B8BC: CBA6     [42]     	res	4,(hl)		; reset disable gen input flag
B8BE: CBAE     [57]     	res	5,(hl)		; reset rectangle flag
B8C0: CD5601   [74]     	call	kilbuf		; clear keyboard buffer
B8C3: C9       [84]     	ret
                        
B8C4:                   preprectcurs:			; prepare the rectangle cursors
                        					; change rectangle cursors patterns
B8C4: 3A67C4   [13]     	ld	a,(rectt)		; get rectangle type for the sprite shape
B8C7: 3C       [17]     	inc	a			; increment 1 to sync shape with type
B8C8: 2A83C4   [33]     	ld	hl,(spboxfil+6)	; get box fil sprite y pos
B8CB: 23       [39]     	inc	hl			; inc to pattern number
B8CC: 23       [45]     	inc	hl			;
B8CD: CD4D00   [62]     	call	wrtvrm		; assign
B8D0: 2A94C4   [78]     	ld	hl,(spboxhol+6)	; get box hol sprite y pos
B8D3: 23       [84]     	inc	hl			; inc to pattern number
B8D4: 23       [90]     	inc	hl			;
B8D5: CD4D00   [107]    	call	wrtvrm		; assign
B8D8: 2AA5C4   [123]    	ld	hl,(spboxlin+6)	; get box line sprite y pos
B8DB: 23       [129]    	inc	hl			; inc to pattern number
B8DC: 23       [135]    	inc	hl			;
B8DD: CD4D00   [152]    	call	wrtvrm		; assign
B8E0: 2AB6C4   [168]    	ld	hl,(spboxadd+6)	; get box line add sprite y pos
B8E3: 23       [174]    	inc	hl			; inc to pattern number
B8E4: 23       [180]    	inc	hl			;
B8E5: CD4D00   [197]    	call	wrtvrm		; assign
B8E8: CDA6C3   [214]    	call	hidecharcur		; hide character cursor
B8EB: C9       [224]    	ret
                        
B8EC:                   getvramrectpos:			; get VRAM data from rectangle cursor positions
                        					; input: CURAT0-3 cursor variable (y,x,y1,x1) pixels (255,191)
                        					; output: RECTT1-4 rectangle variables (start addr,width,height) VRAM bytes
                        
                        					; swap x<>x1, y<>y1 if the former is bigger
B8EC: 3A2DC4   [13]     	ld	a,(curat)		; get cursor pos y (current)
B8EF: 212FC4   [23]     	ld	hl,curat+2		; get location for cursor pos y1 (anchor)
B8F2: BE       [30]     	cp	(hl)			; compare y with y1
B8F3: 380B     [37|42]  	jr	c,acniy		; if y1 greater than y jump over swap
B8F5: 47       [41]     	ld	b,a			; put y in B
B8F6: 3A2FC4   [54]     	ld	a,(curat+2)		; get y1
B8F9: 322DC4   [67]     	ld	(curat),a		; put in previous y pos
B8FC: 78       [71]     	ld	a,b			; get y back from B
B8FD: 322FC4   [84]     	ld	(curat+2),a		; put in previous y1 pos
B900: 3A2EC4   [13]     acniy:ld	a,(curat+1)		; get cursor pos x (current)
B903: 2130C4   [23]     	ld	hl,curat+3		; get location for cursor pos x1 (anchor)
B906: BE       [30]     	cp	(hl)			; compare x with x1
B907: 380B     [37|42]  	jr	c,acnix		; if x1 greater then x jump over swap
B909: 47       [41]     	ld	b,a			; put x in B
B90A: 3A30C4   [54]     	ld	a,(curat+3)		; get x1
B90D: 322EC4   [67]     	ld	(curat+1),a		; put in previous x1 pos
B910: 78       [71]     	ld	a,b			; get x back from B
B911: 3230C4   [84]     	ld	(curat+3),a		; put in previous x1 pos
                        					; get VRAM pos,w,h from x,y,x1,y1
B914: 2A2DC4   [16]     acnix:ld	hl,(curat)		; get x,y (read bytes pos inverted)
B917: CD10C4   [33]     	call	vrampos		; convert to VRAM position
B91A: 2268C4   [49]     	ld	(rectt+1),hl	; save to rectangle RAM
                        					; get height from y and y1
B91D: 3A2DC4   [62]     	ld	a,(curat)		; get y
B920: 47       [66]     	ld	b,a			; send to B
B921: 3A2FC4   [79]     	ld	a,(curat+2)		; get y1
B924: 90       [83]     	sub	b			; subtract y from y1
B925: 0F       [87]     	rrca				; divide by 2
B926: 0F       [91]     	rrca				; divide by 4
B927: 0F       [95]     	rrca				; divide by 8
B928: 3C       [99]     	inc	a			; add another position
B929: 326AC4   [112]    	ld	(rectt+3),a		; save height in bytes
                        					; get width from x and x1
B92C: 3A2EC4   [125]    	ld	a,(curat+1)		; get x
B92F: 47       [129]    	ld	b,a			; send to B
B930: 3A30C4   [142]    	ld	a,(curat+3)		; get x1
B933: 90       [146]    	sub	b			; subtract x from x1
B934: 0F       [150]    	rrca				; divide by 2
B935: 0F       [154]    	rrca				; divide by 4
B936: 0F       [158]    	rrca				; divide by 8
B937: 3C       [162]    	inc	a			; add another position
B938: 326BC4   [175]    	ld	(rectt+4),a		; save width in bytes
B93B: C9       [185]    	ret
                        
B93C:                   pasteoldbuf:			; paste from existing buffer content
                        					; check if copy in buffer
B93C: 3A46D1   [13]     	ld	a,(buffcont1)	; get buffer 1 height
B93F: 47       [17]     	ld	b,a			; put in B
B940: 3A47D1   [30]     	ld	a,(buffcont1+1)	; get buffer 1 width
B943: B0       [34]     	or	b			; combine height with width
B944: FE00     [41]     	cp	0x00			; is any of them 0?
B946: C8       [46|52]  	ret	z			; if so, return
B947: CDC4C2   [63]     	call	setundo		; copy screen for undo
                        					; define area and activate paste mode
B94A: 2A46D1   [79]     	ld	hl,(buffcont1)	; get buffer 1 content dimensions
B94D: 226AC4   [95]     	ld	(rectt+3),hl	; put on rectangle variable
B950: CD63B9   [112]    	call	getpasteold		; activate paste mode
B953: CD5601   [129]    	call	kilbuf		; clear keyboard buffer
B956: C9       [139]    	ret
                        
B957:                   getpastebox:			; copy the rectangle area
B957: 2A2DC4   [16]     	ld	hl,(curat)		; get current x,y cursor pos
B95A: 2231C4   [32]     	ld	(curat+4),hl	; put on saved to keep the tpo left corner
B95D: 1148D1   [42]     	ld	de,buffer1		; get RAM area to copy to
B960: CD71C3   [59]     	call	boxvrb1		; copy VRAM to RAM
B963:                   getpasteold:			; entry point for getting existing buffer
B963: 3E06     [ 7]     	ld	a,0x06		; get number of paste sprite (ninus 1)
B965: 3267C4   [20]     	ld	(rectt),a		; put in memory
B968: CDC4B8   [37]     	call	preprectcurs	; prepare rectangle cursors
                        					; set flags
B96B: 2108B0   [47]     	ld	hl,flags		; get flags byte
B96E: CBE6     [62]     	set	4,(hl)		; set dis gen input flag
B970: CBDE     [77]     	set	3,(hl)		; set paste box flag
B972: C9       [87]     	ret
                        
B973:                   showpastebox:			; show the content to be pasted
B973: 2A2DC4   [16]     	ld	hl,(curat)		; get current cursor position
B976: CD10C4   [33]     	call	vrampos		; convert to VRAM pos
B979: 2268C4   [49]     	ld	(rectt+1),hl	; save in memory
                        					; save screen area
B97C: 1148D4   [59]     	ld	de,buffer2		; get the RAM area to copy to
B97F: CD77C3   [76]     	call	boxvrb2		; save VRAM area under cursor to RAM
                        					; draw paste content on the screen
B982: 2148D1   [86]     	ld	hl,buffer1		; get copied data RAM area
B985: CD40C3   [103]    	call	boxrv			; show on the screen at the cursor position
                        					; do stuff while the content is shown on screen
                        					; update y1 position
B988: 3A2DC4   [116]    	ld	a,(curat)		; get y
B98B: 47       [120]    	ld	b,a			; copy to B
B98C: 3A6AC4   [133]    	ld	a,(rectt+3)		; get height
B98F: 3D       [137]    	dec	a			; decrement 1 row
B990: 07       [141]    	rlca				; multiply by 2
B991: 07       [145]    	rlca				; multiply by 4
B992: 07       [149]    	rlca				; multiply by 8
B993: 80       [153]    	add	b			; add to y
B994: 212FC4   [163]    	ld	hl,curat+2		; get y1 mem pos
B997: 77       [170]    	ld	(hl),a		; save y to y1
                        					; update x1 position
B998: 3A2EC4   [183]    	ld	a,(curat+1)		; get x
B99B: 47       [187]    	ld	b,a			; copy to B
B99C: 3A6BC4   [200]    	ld	a,(rectt+4)		; get width
B99F: 3D       [204]    	dec	a			; decrement 1 column
B9A0: 07       [208]    	rlca				; multiply by 2
B9A1: 07       [212]    	rlca				; multiply by 4
B9A2: 07       [216]    	rlca				; multiply by 8
B9A3: 80       [220]    	add	b			; add to x
B9A4: 2130C4   [230]    	ld	hl,curat+3		; get x1 mem pos
B9A7: 77       [237]    	ld	(hl),a		; save x to x1
                        
B9A8: CD04B8   [254]    	call	showrectcurs	; show the rectangle cursors
                        					; put original content back on the screen
B9AB: 2148D4   [264]    	ld	hl,buffer2		; get the RAM area to copy from
B9AE: CD40C3   [281]    	call	boxrv			; restore area under the cursor
B9B1: C9       [291]    	ret
                        
B9B2:                   pastethebox:			; actually paste the copied area
B9B2: 2A2DC4   [16]     	ld	hl,(curat)		; get current cursor position
B9B5: CD10C4   [33]     	call	vrampos		; convert to VRAM pos
B9B8: 2268C4   [49]     	ld	(rectt+1),hl	; save in memory
B9BB: 2148D1   [59]     	ld	hl,buffer1		; get copied data RAM area
B9BE: CD40C3   [76]     	call	boxrv			; paste to the screen at the cursor position
B9C1: C9       [86]     	ret
                        
B9C2:                   erasewithbox:			; erase screen area with the paste box
B9C2: 2A2DC4   [16]     	ld	hl,(curat)		; get current cursor position
B9C5: CD10C4   [33]     	call	vrampos		; convert to VRAM pos
B9C8: 2268C4   [49]     	ld	(rectt+1),hl	; save in memory
B9CB: 3A33C4   [62]     	ld	a,(curat+6)		; get current char
B9CE: F5       [73]     	push	af			; save for later
B9CF: 3A35C4   [86]     	ld	a,(curat+8)		; get erase char
B9D2: 3233C4   [99]     	ld	(curat+6),a		; put in current char
B9D5: CD0EBA   [116]    	call	drawboxfil		; draw a filled box with it
B9D8: F1       [126]    	pop	af			; get saved char
B9D9: 3233C4   [139]    	ld	(curat+6),a		; put back in current
B9DC: C9       [149]    	ret
                        
B9DD:                   cancelpaste:			; cancel the paste box
B9DD: CDB5C3   [17]     	call	hideboxcur		; hide box cursors
                        					; reset flags
B9E0: 2108B0   [27]     	ld	hl,flags		; get flags byte
B9E3: CB9E     [42]     	res	3,(hl)		; reset dis gen input flag
B9E5: CBA6     [57]     	res	4,(hl)		; reset paste box flag
B9E7: CD5601   [74]     	call	kilbuf		; clear keyboard buffer
B9EA: C9       [84]     	ret
                        
B9EB:                   drawboxchr:				; draw a filled box with sequential chars
B9EB: 2A68C4   [16]     	ld	hl,(rectt+1)	; get initial VRAM position
B9EE: 3A6BC4   [29]     	ld	a,(rectt+4)		; get width
B9F1: 47       [33]     	ld	b,a			; put in B
B9F2: D620     [40]     	sub	0x20			; subtract from screen width
B9F4: ED44     [48]     	neg				; negative it cause screen is bigger
B9F6: 5F       [52]     	ld	e,a			; put in DE
B9F7: 1600     [59]     	ld	d,0x00		;
B9F9: 3A6AC4   [72]     	ld	a,(rectt+3)		; get height
B9FC: 4F       [76]     	ld	c,a			; put in C
B9FD: 3A33C4   [89]     	ld	a,(curat+6)		; get current character
BA00: C5       [11]     ldbc2:push	bc			; save counters
BA01: CDFEC3   [17]     ldbc1:call	wrtvrms		; write character
BA04: 23       [23]     	inc	hl			; increment column
BA05: 3C       [27]     	inc	a			; increment character index
BA06: 10F9     [35|40]  	djnz	ldbc1			; do whole width
BA08: C1       [45]     	pop	bc			; restore counters
BA09: 19       [56]     	add	hl,de			; go to next screen line
BA0A: 0D       [60]     	dec	c			; decrement one height unit
BA0B: 20F3     [67|72]  	jr	nz,ldbc2		; if not 0, loop
BA0D: C9       [77]     	ret
                        
BA0E:                   drawboxfil:				; draw a filled box with the curr char
BA0E: 2A68C4   [16]     	ld	hl,(rectt+1)	; get initial VRAM position
BA11: 3A6BC4   [29]     	ld	a,(rectt+4)		; get width
BA14: 47       [33]     	ld	b,a			; put in B
BA15: 3A6AC4   [46]     	ld	a,(rectt+3)		; get height
BA18: 4F       [50]     	ld	c,a			; put in C
BA19: E5       [61]     	push	hl			; save initial VRAM position
BA1A: CDECBA   [17]     ldbfl:call	drawhorizline	; draw line
BA1D: E1       [27]     	pop	hl			; restore VRAM position
BA1E: 112000   [37]     	ld	de,0x20		; get VRAM line advance amount
BA21: 19       [48]     	add	hl,de			; add one screen line
BA22: E5       [59]     	push	hl			; save VRAM position
BA23: 3A6BC4   [72]     	ld	a,(rectt+4)		; restore width
BA26: 47       [76]     	ld	b,a			; put in B
BA27: 0D       [80]     	dec	c			; decrement one height unit
BA28: 20F0     [87|92]  	jr	nz,ldbfl		; if not 0, loop
BA2A: E1       [97]     	pop	hl			; clear remnant stack push
BA2B: C9       [107]    	ret
                        
BA2C:                   drawboxhol:				; draw a hollow box with the cur char
                        					; upper line
BA2C: 2A68C4   [16]     	ld	hl,(rectt+1)	; get initial VRAM pos
BA2F: 3A6BC4   [29]     	ld	a,(rectt+4)		; get width
BA32: 47       [33]     	ld	b,a			; put in B
BA33: CDECBA   [50]     	call	drawhorizline	; draw line
                        					; right line (use updated HL pos)
BA36: 2B       [56]     	dec	hl			; back VRAM one x position
BA37: 3A6AC4   [69]     	ld	a,(rectt+3)		; get height
BA3A: 47       [73]     	ld	b,a			; put in B
BA3B: CDE7BA   [90]     	call	drawvertline	; draw line	ret
                        					; left line
BA3E: 2A68C4   [106]    	ld	hl,(rectt+1)	; get initial VRAM pos
BA41: 3A6AC4   [119]    	ld	a,(rectt+3)		; get height
BA44: 47       [123]    	ld	b,a			; put in B
BA45: CDE7BA   [140]    	call	drawvertline	; draw line
                        					; lower line (use updated HL pos and assigned DE)
BA48: ED52     [155]    	sbc	hl,de			; back VRAM one line
BA4A: 3A6BC4   [168]    	ld	a,(rectt+4)		; get width
BA4D: 47       [172]    	ld	b,a			; put in B
BA4E: CDECBA   [189]    	call	drawhorizline	; draw line
BA51: C9       [199]    	ret
                        
BA52:                   drawboxlin:				; draw a line box with or without adding the lines
                        					; if box = 1x1 draw a cross
BA52: 2A6AC4   [16]     	ld	hl,(rectt+3)	; get w,h
BA55: 110101   [26]     	ld	de,0x0101		; see if both are 1
BA58: CD2000   [43]     	call	dcompr		; compare them
BA5B: 2009     [50|55]  	jr	nz,sdbl1		; if any is different, skip
BA5D: 2A68C4   [66]     	ld	hl,(rectt+1)	; get initial VRAM pos
BA60: 3E15     [73]     	ld	a,0x15		; get cross line character
BA62: CDFEC3   [90]     	call	wrtvrms		; write on the screen
BA65: C9       [100]    	ret
                        					; if box has no width draw vert line
BA66: 3E01     [ 7]     sdbl1:ld	a,0x01		; get 1 to compare
BA68: BC       [11]     	cp	h			; compare with width
BA69: 200D     [18|23]  	jr	nz,sdbl2		; if is not, skip
BA6B: 45       [22]     	ld	b,l			; if it is put height on counter
BA6C: 3E16     [29]     	ld	a,0x16		; get the vertical bar character
BA6E: 3233C4   [42]     	ld	(curat+6),a		; put on current character
BA71: 2A68C4   [58]     	ld	hl,(rectt+1)	; get initial VRAM pos
BA74: CDE7BA   [75]     	call	drawvertline	; draw line
BA77: C9       [85]     	ret
                        					; if box has no height draw horiz line
BA78: 3E01     [ 7]     sdbl2:ld	a,0x01		; get 1 to compare
BA7A: BD       [11]     	cp	l			; compare with height
BA7B: 200D     [18|23]  	jr	nz,sdbl3		; if is not, skip
BA7D: 44       [22]     	ld	b,h			; if it is put width on counter
BA7E: 3E17     [29]     	ld	a,0x17		; get the horizontal bar character
BA80: 2A68C4   [45]     	ld	hl,(rectt+1)	; get initial VRAM pos
BA83: 3233C4   [58]     	ld	(curat+6),a		; put on current character
BA86: CDECBA   [75]     	call	drawhorizline	; draw line
BA89: C9       [85]     	ret
BA8A: 3A33C4   [13]     sdbl3:ld	a,(curat+6)		; get current character
BA8D: F5       [24]     	push	af			; save it to retrieve at the end
                        					; upper line
BA8E: 2A68C4   [40]     	ld	hl,(rectt+1)	; get initial VRAM pos
BA91: 3E18     [47]     	ld	a,0x18		; get top left corner character
BA93: CDFDBA   [64]     	call	drawrectch		; write it according to type
BA96: 23       [70]     	inc	hl			; go to next column to spare the corner
BA97: 3A6BC4   [83]     	ld	a,(rectt+4)		; get width
BA9A: 3D       [87]     	dec	a			; decrease 2 to spare the corner
BA9B: 3D       [91]     	dec	a			;
BA9C: 47       [95]     	ld	b,a			; put in B
BA9D: 3E17     [102]    	ld	a,0x17		; get horizontal bar character
BA9F: 3233C4   [115]    	ld	(curat+6),a		; put on current character
BAA2: CDECBA   [132]    	call	drawhorizline	; draw line
BAA5: 3E19     [139]    	ld	a,0x19		; get top right corner character
BAA7: CDFDBA   [156]    	call	drawrectch		; write it according to type
                        					; right line (use updated HL pos)
BAAA: 3A6AC4   [169]    	ld	a,(rectt+3)		; get height
BAAD: 3D       [173]    	dec	a			; decrease 2 to spare the corner
BAAE: 3D       [177]    	dec	a			;
BAAF: 47       [181]    	ld	b,a			; put in B
BAB0: 112000   [191]    	ld	de,0x20		; increment for advancing screen line
BAB3: 19       [202]    	add	hl,de			; go to next line to spare the corner
BAB4: 3E16     [209]    	ld	a,0x16		; get vertical bar character
BAB6: 3233C4   [222]    	ld	(curat+6),a		; put on current character
BAB9: CDE7BA   [239]    	call	drawvertline	; draw line
BABC: 3E1B     [246]    	ld	a,0x1b		; get bottom right corner character
BABE: CDFDBA   [263]    	call	drawrectch		; write it according to type
                        					; left line
BAC1: 2A68C4   [279]    	ld	hl,(rectt+1)	; get initial VRAM pos
BAC4: 19       [290]    	add	hl,de			; go to next line to spare the corner
BAC5: 3A6AC4   [303]    	ld	a,(rectt+3)		; get height
BAC8: 3D       [307]    	dec	a			; decrease 2 to spare the corner
BAC9: 3D       [311]    	dec	a			;
BACA: 47       [315]    	ld	b,a			; put in B
BACB: CDE7BA   [332]    	call	drawvertline	; draw line
BACE: 3E1A     [339]    	ld	a,0x1a		; get bottom left corner character
BAD0: CDFDBA   [356]    	call	drawrectch		; write it according to type
                        					; lower line (use updated HL pos and assigned DE)
BAD3: 3A6BC4   [369]    	ld	a,(rectt+4)		; get width
BAD6: 3D       [373]    	dec	a			; decrease 2 to spare the corner
BAD7: 3D       [377]    	dec	a			;
BAD8: 47       [381]    	ld	b,a			; put in B
BAD9: 23       [387]    	inc	hl			; go to next column to spare the corner
BADA: 3E17     [394]    	ld	a,0x17		; get horizontal bar character
BADC: 3233C4   [407]    	ld	(curat+6),a		; put on current character
BADF: CDECBA   [424]    	call	drawhorizline	; draw line
BAE2: F1       [434]    	pop	af			; restore current character
BAE3: 3233C4   [447]    	ld	(curat+6),a		; put it back on memory
BAE6: C9       [457]    	ret
                        
BAE7:                   drawvertline:			; draw a vertical or horizontal line
                        					; input: HL=VRAM start,B=height,CURAT+6=cur char,RECTT=rect type(for DRAWRECTCH)
BAE7: 112000   [10]     	ld	de,0x20		; increment for advancing VRAM pos
BAEA: 1803     [22]     	jr	sdrli			; skip to draw routine
BAEC:                   drawhorizline:			; entry point for horizontal line
BAEC: 110100   [10]     	ld	de,0x01		; increment for advancing VRAM pos
                        					; check if has any length
BAEF: 3E00     [ 7]     sdrli:ld	a,0x00		; get 0 to compare
BAF1: B8       [11]     	cp	b			; compare to length
BAF2: C8       [16|22]  	ret	z			; if match, go back
BAF3: 3A33C4   [13]     ldrli:ld	a,(curat+6)		; get current character
BAF6: CDFDBA   [30]     	call	drawrectch		; write it according to type
BAF9: 19       [41]     	add	hl,de			; increase VRAM pos
BAFA: 10F7     [49|54]  	djnz	ldrli			; decrease length, if not 0, loop
BAFC: C9       [59]     	ret
                        
BAFD:                   drawrectch:				; draw character depending on rectangle type
                        					; input: HL=VRAM pos,A=curr char,RECTT=rectangle type
BAFD: F5       [11]     	push	af			; save current character
BAFE: 3A67C4   [24]     	ld	a,(rectt)		; get rectangle type
BB01: FE03     [31]     	cp	0x03			; is line add?
BB03: 202D     [38|43]  	jr	nz,sdrr1		; if not, skip to next test
                        					; draw characters adding lines
                        					; check character already on the screen
BB05: CD4A00   [55]     	call	rdvrm			; get char on the screen
BB08: FE10     [62]     	cp	0x10			; compare with lower lines character
BB0A: 3826     [69|74]  	jr	c,sdrr1		; if lower, skip everything
BB0C: FE1C     [76]     	cp	0x1c			; compare with higher lines character
BB0E: 3022     [83|88]  	jr	nc,sdrr1		; if higher, skip everything
                        					; draw according to what already is on the screen position
BB10: F1       [93]     	pop	af			; remove old AF from stack
BB11: E5       [104]    	push	hl			; save VRAM position
BB12: D9       [108]    	exx				; save BC,DE,HL
                        					; replace characters using a Look Up Table
                        					; calculate LUT row to use
BB13: 0615     [115]    	ld	b,0x15		; the lowest possible curr char number -1
BB15: 90       [119]    	sub	b			; subtract from the current char number
BB16: 47       [123]    	ld	b,a			; put result in B for the counter
BB17: 3E00     [130]    	ld	a,0			; prepare A for the count
BB19: 1E0B     [137]    	ld	e,11			; get the number to advance a LUT row
BB1B: 83       [ 4]     ldrre:add	a,e			; advance a row in the LUT
BB1C: 10FD     [12|17]  	djnz	ldrre			; decrement counter and loop if not 0
BB1E: 93       [16]     	sub	e			; go to the start of the current LUT row
BB1F: 5F       [20]     	ld	e,a			; put calculated LUT row in E
                        					; calculate LUT column
BB20: E1       [30]     	pop	hl			; restore VRAM position
BB21: CD4A00   [47]     	call	rdvrm			; get character in it
BB24: 0611     [54]     	ld	b,0x11		; the lowest line char number minus
BB26: 90       [58]     	sub	b			; subtract from the screen char number
BB27: 83       [62]     	add	a,e			; add to the LUT row
BB28: 1600     [69]     	ld	d,0			; put LUT position in DE
BB2A: 5F       [73]     	ld	e,a			;
BB2B: 2104D1   [83]     	ld	hl,lineaddlut	; get LUT start address
BB2E: 19       [94]     	add	hl,de			; add to calculated number
BB2F: 7E       [101]    	ld	a,(hl)		; get character in that address
BB30: F5       [112]    	push	af			; save character from LUT
BB31: D9       [116]    	exx				; restore BC,DE,HL
BB32: F1       [10]     sdrr1:pop	af			; restore saved char
BB33: CDFEC3   [27]     	call	wrtvrms		; write on the screen
BB36: C9       [37]     	ret
                        #include "masciiEC.asm"		; edit characters
                        ; ------------------EDIT CHARACTER
                        
BB37:                   showeditchrscr:			; edit character set
                        					; save the contents of the VRAM
                        					; screen
BB37: 210018   [10]     	ld	hl,0x1800		; VRAM position from
BB3A: 110014   [20]     	ld	de,VRBUF4		; VRAM position to
BB3D: 010003   [30]     	ld	bc,0x0300		; length
BB40: CD0BC3   [47]     	call	streamvv		; copy
                        					; patterns
BB43: 210000   [57]     	ld	hl,0x0000		; VRAM position from
BB46: 110028   [67]     	ld	de,VRBUF5		; VRAM position to
BB49: 010008   [77]     	ld	bc,0x0800		; length
BB4C: CD0BC3   [94]     	call	streamvv		; copy
                        					; colors
BB4F: 210020   [104]    	ld	hl,0x2000		; VRAM position from
BB52: 110030   [114]    	ld	de,VRBUF6		; VRAM position to
BB55: 010008   [124]    	ld	bc,0x0800		; length
BB58: CD0BC3   [141]    	call	streamvv		; copy
BB5B: CD75BB   [158]    	call	initworkchrs	; initialize working characters
                        					; draw screen elements
BB5E: 3A33C4   [171]    	ld	a,(curat+6)		; get the current character
BB61: CDCBBC   [188]    	call	initgrid		; draw the editing grid
BB64: 218318   [198]    	ld	hl,0x1883		; top left position for char map
BB67: CD1EC3   [215]    	call	createcharmap	; draw the character map
                        					; set flags
BB6A: 2108B0   [225]    	ld	hl,flags		; get flags byte
BB6D: CBCE     [240]    	set	1,(hl)		; set char map flag
BB6F: CBE6     [255]    	set	4,(hl)		; set dis gen input flag
BB71: CD5601   [272]    	call	kilbuf		; clear keyboard buffer
BB74: C9       [282]    	ret
                        
BB75:                   initworkchrs:			; initialize edit character screen
                        					; backup chars used for working
                        					; patterns
BB75: 3AA4C5   [13]     	ld	a,(editwork)	; get first working character
BB78: CDB6BE   [30]     	call	getpatternad	; get its pattern address
BB7B: 1168C5   [40]     	ld	de,editbkch		; get the backup address
BB7E: 011800   [50]     	ld	bc,0x18		; get the amount to backup
BB81: CD5900   [67]     	call	ldirmv		; copy
                        					; colors
BB84: 3AA4C5   [80]     	ld	a,(editwork)	; get first working character
BB87: CDA9BE   [97]     	call	getcolorfrchr	; get its color address
BB8A: 1180C5   [107]    	ld	de,editbkcl		; get the backup address
BB8D: 010100   [117]    	ld	bc,0x01		; length to backup (prepare for high color)
BB90: CD5900   [134]    	call	ldirmv		; copy
                        					; create the working characters
BB93: 3AA4C5   [147]    	ld	a,(editwork)	; get first working character
BB96: CDB6BE   [164]    	call	getpatternad	; get its pattern address
BB99: 2138C5   [174]    	ld	hl,editonch		; working chars RAM pattern address
BB9C: 011800   [184]    	ld	bc,0x18		; length
BB9F: CD5C00   [201]    	call	ldirvm		; copy
                        					; color the working characters
BBA2: 3AA4C5   [214]    	ld	a,(editwork)	; get first working character
BBA5: CDA9BE   [231]    	call	getcolorfrchr	; get its color address
BBA8: 54       [235]    	ld	d,h			; put in DE
BBA9: 5D       [239]    	ld	e,l 			;
BBAA: 2150C5   [249]    	ld	hl,editoncl		; get its color address
BBAD: 010100   [259]    	ld	bc,0x01		; length (prepare for high color)
BBB0: CD5C00   [276]    	call	ldirvm		; write
                        					; clear the screen w custom char
BBB3: 3AA6C5   [289]    	ld	a,(editwork+2)	; choose a background character
BBB6: 210018   [299]    	ld	hl,0x1800		; start of the screen address
BBB9: 010003   [309]    	ld	bc,0x300		; screen length
BBBC: CD5600   [326]    	call	filvrm		; fill the screen
BBBF: C9       [336]    	ret
                        
BBC0:                   restworkchrs:			; restore chars used for working
                        					; patterns
BBC0: 3AA4C5   [13]     	ld	a,(editwork)	; get first working character
BBC3: CDB6BE   [30]     	call	getpatternad	; get its pattern address
BBC6: 2168C5   [40]     	ld	hl,editbkch		; get the backup address
BBC9: 011800   [50]     	ld	bc,0x18		; get the amount to restore
BBCC: CD5C00   [67]     	call	ldirvm		; copy
                        					; colors
BBCF: 3AA4C5   [80]     	ld	a,(editwork)	; get first working character
BBD2: CDA9BE   [97]     	call	getcolorfrchr	; get its color address
BBD5: 54       [101]    	ld	d,h			; put in DE
BBD6: 5D       [105]    	ld	e,l 			;
BBD7: 2180C5   [115]    	ld	hl,editbkcl		; get the backup address
BBDA: 010100   [125]    	ld	bc,0x01		; length to restore (prepare for high color)
BBDD: CD5C00   [142]    	call	ldirvm		; copy
BBE0: C9       [152]    	ret
                        
BBE1:                   swapwrkchrs:			; swap working characters
BBE1: CDC0BB   [17]     	call	restworkchrs	; restore chars used for working
                        					; swap the working characters information
BBE4: 2AA8C5   [33]     	ld	hl,(editwork+4)	; get the address of the other set
BBE7: 11A4C5   [43]     	ld	de,editwork		; get the address of the active set
BBEA: 010600   [53]     	ld	bc,0x06		; get the amount to copy
BBED: EDB0     [69|21]  	ldir				; copy
BBEF: CD75BB   [86]     	call	initworkchrs	; initialize the working characters
                        					; redraw the screen
BBF2: 3A37C4   [99]     	ld	a,(edtch)		; get the editing character
BBF5: CD33BD   [116]    	call	drawgrid		; draw the editing grid
BBF8: 218318   [126]    	ld	hl,0x1883		; top left position for char map
BBFB: CD1EC3   [143]    	call	createcharmap	; draw the character map
BBFE: CD5601   [160]    	call	kilbuf		; clear keyboard buffer
BC01: C9       [170]    	ret
                        
BC02:                   savewrkchrs:			; save working characters. grid and background
                        					; create the working characters
BC02: 3AA4C5   [13]     	ld	a,(editwork)	; get first working character
BC05: CDB6BE   [30]     	call	getpatternad	; get its pattern address
BC08: 1138C5   [40]     	ld	de,editonch		; working chars RAM pattern address
BC0B: 011800   [50]     	ld	bc,0x18		; length
BC0E: CD5900   [67]     	call	ldirmv		; copy
                        					; color the working characters
BC11: 3AA4C5   [80]     	ld	a,(editwork)	; get first working character
BC14: CDA9BE   [97]     	call	getcolorfrchr	; get its color address
BC17: 1150C5   [107]    	ld	de,editoncl		; get the backup address
BC1A: 010100   [117]    	ld	bc,0x01		; length to restore (prepare for high color)
BC1D: CD5900   [134]    	call	ldirmv		; copy
BC20: CD5601   [151]    	call	kilbuf		; clear keyboard buffer
BC23: C9       [161]    	ret
                        
BC24:                   clearmapcurs:			; clear grid cursor when cursor not above
BC24: 3ED1     [ 7]     	ld	a,209			; y position to turn off sprite
BC26: 2A1CC5   [23]     	ld	hl,(spcharac+6)	; character cursor VRAM attribute pos y
BC29: CD4D00   [40]     	call	wrtvrm		; write
BC2C: 2A2DC5   [56]     	ld	hl,(spbckgrd+6)	; background cursor VRAM attribute pos y
BC2F: CD4D00   [73]     	call	wrtvrm		; write
BC32: C9       [83]     	ret
                        
BC33:                   insidecharmap:			; cursor inside character map
BC33: CD6BBD   [17]     	call	testmaparea		; test if inside map area
BC36: 30EC     [24|29]  	jr	nc,clearmapcurs	; if not, leave
BC38: CD23B2   [41]     	call	chosefrommap	; show choosing cursor
BC3B: C9       [51]     	ret
                        
BC3C:                   cleargridcurs:			; clear map char cursor when cursor not above
BC3C: 3ED1     [ 7]     	ld	a,209			; y position to turn off sprite
BC3E: 2AFAC4   [23]     	ld	hl,(speditch+6)	; grid cursor VRAM attribute pos y
BC41: CD4D00   [40]     	call	wrtvrm		; write
BC44: C9       [50]     	ret
                        
BC45:                   insideeditarea:			; cursor inside editing grid
BC45: CD86BD   [17]     	call	testgridrea		; test if inside grid area
BC48: 30F2     [24|29]  	jr	nc,cleargridcurs	; if not, leave
BC4A: 3A2DC4   [37]     	ld	a,(curat)		; get pos y
BC4D: C604     [44]     	add	4			; offset cursor
BC4F: E6F8     [51]     	and	0b11111000		; step by 8 increments
BC51: 3D       [55]     	dec	a			; adjust for y sprite offset
BC52: 2AFAC4   [71]     	ld	hl,(speditch+6)	; character cursor VRAM attribute pos y
BC55: CD4D00   [88]     	call	wrtvrm		; write pos y to VRAM
                        
BC58: 3A2EC4   [101]    	ld	a,(curat+1)		; get pos x
BC5B: C604     [108]    	add	4			; offset cursor
BC5D: E6F8     [115]    	and	0b11111000		; step by 8 increments
BC5F: 2AFAC4   [131]    	ld	hl,(speditch+6)	; character cursor VRAM attribute pos y
BC62: 23       [137]    	inc	hl			; inc to pos x
BC63: CD4D00   [154]    	call	wrtvrm		; write pos y to VRAM
BC66: C9       [164]    	ret
                        
BC67:                   canceledit:				; cancel character edit. restore all
BC67: 3A33C4   [13]     	ld	a,(curat+6)		; get the current character
BC6A: 3237C4   [26]     	ld	(edtch),a		; put in editing character
                        					; restore the contents of the VRAM
                        					; patterns
BC6D: 210028   [36]     	ld	hl,VRBUF5		; VRAM position from
BC70: 110000   [46]     	ld	de,0x0000		; VRAM position to
BC73: 010008   [56]     	ld	bc,0x0800		; length
BC76: CD0BC3   [73]     	call	streamvv		; copy
                        					; colors
BC79: 210030   [83]     	ld	hl,VRBUF6		; VRAM position from
BC7C: 110020   [93]     	ld	de,0x2000		; VRAM position to
BC7F: 010008   [103]    	ld	bc,0x0800		; length
BC82: CD0BC3   [120]    	call	streamvv		; copy
BC85:                   acceptedit:				; accept character edit. restore screen only
BC85: CDC0BB   [17]     	call	restworkchrs	; restore chars used for working
                        					; restore cursors
BC88: 3A37C4   [30]     	ld	a,(edtch)		; get the editing character
BC8B: 3233C4   [43]     	ld	(curat+6),a		; put in current character
BC8E: CD1CB5   [60]     	call	getcharshape	; put character shape on sprite
BC91: CD2DB5   [77]     	call	getcharcolor	; put character color on sprite
BC94: CD3CBC   [94]     	call	cleargridcurs	; remove grid cursor
                        					; restore screen
BC97: 210014   [104]    	ld	hl,VRBUF4		; VRAM position from
BC9A: 110018   [114]    	ld	de,0x1800		; VRAM position to
BC9D: 010003   [124]    	ld	bc,0x0300		; length
BCA0: CD0BC3   [141]    	call	streamvv		; copy
                        					; reset flags
BCA3: 2108B0   [151]    	ld	hl,flags		; get flags byte
BCA6: CB8E     [166]    	res	1,(hl)		; reset rectangle flag
BCA8: CBA6     [181]    	res	4,(hl)		; reset disable gen input flag
BCAA: CD5601   [198]    	call	kilbuf		; clear keyboard buffer
BCAD: C9       [208]    	ret
                        
BCAE:                   enterredit:				; trigger with keyboard (to kill key buffer)
BCAE: CDB5BC   [17]     	call	triggeredit		; call trigger
BCB1: CD5601   [34]     	call	kilbuf		; clear keyboard buffer 
BCB4: C9       [44]     	ret
                        
BCB5:                   triggeredit:			; check if trigger inside map or grid
BCB5: CD6BBD   [17]     	call	testmaparea		; test if cursor inside the char map area
BCB8: DAC2BC   [27|27]  	jp	c,triggermap	; if so, perform char map area actions
BCBB: CD86BD   [44]     	call	testgridrea		; test if cursor inside the grid area
BCBE: DAD8BC   [54|54]  	jp	c,triggergrid	; if so, perform grid area actions
BCC1: C9       [64]     	ret
                        
BCC2:                   triggermap:				; trigger inside char map
BCC2: 2A2DC4   [16]     	ld	hl,(curat)		; get xy cursor position
BCC5: CD10C4   [33]     	call	vrampos		; get VRAM cursor position
BCC8: CD4A00   [50]     	call	rdvrm			; get character below
BCCB:                   initgrid:				; entry point for initializing
BCCB: 3237C4   [13]     	ld	(edtch),a		; save in editing character
BCCE: CDCABD   [30]     	call edtsetundo		; copy char to undo buffer
BCD1: 3A37C4   [43]     	ld	a,(edtch)		; get editing character
BCD4: CD33BD   [60]     	call	drawgrid		; draw an editing grid with character
BCD7: C9       [70]     	ret
                        
BCD8:                   triggergrid:			; toggle grid bits
                        					; do not toggle bit if trig already pressed
BCD8: 2109B0   [10]     	ld	hl,flags+1		; get flags byte
BCDB: CB7E     [22]     	bit	7,(hl)		; is trigger flag set?
BCDD: 2015     [29|34]  	jr	nz,stgg1		; if it is, skip
                        					; if not already pressed, toggle bit
BCDF: CBFE     [44]     	set	7,(hl)		; set trigger flag
BCE1: 2A2DC4   [60]     	ld	hl,(curat)		; get xy cursor position
BCE4: CD10C4   [77]     	call	vrampos		; get VRAM cursor position
BCE7: CD4A00   [94]     	call	rdvrm			; get character below
BCEA: DD21A7C5 [108]    	ld	ix,editwork+3	; get toggle byte
BCEE: DDAE00   [127]    	xor	a,(ix)		; toggle on/off
BCF1: 3238C4   [140]    	ld	(edtch+1),a		; save on grid char
                        					; write bit
BCF4: 2A2DC4   [16]     stgg1:ld	hl,(curat)		; get cursor xy position
BCF7: CD10C4   [33]     	call	vrampos		; get VRAM cursor position
BCFA: 3A38C4   [46]     	ld	a,(edtch+1)		; get grid character
BCFD: CD4D00   [63]     	call	wrtvrm		; write it
BD00: 3A37C4   [76]     	ld	a,(edtch)		; get editing character
BD03: CD07BD   [93]     	call	updatechar		; update the character from the grid
BD06: C9       [103]    	ret
                        
BD07:                   updatechar:				; update character from grid
                        					; input: A=character
BD07: CDB6BE   [17]     	call	getpatternad	; get character pattern address
BD0A: 219518   [27]     	ld	hl,0x1895		; get grid top left corner
BD0D: 0E08     [34]     	ld	c,0x08		; rows/bytes counter
BD0F: 0608     [41]     	ld	b,0x08		; columns/bits counter
BD11: C5       [11]     lupc2:push	bc			; save rows/bytes counter
BD12: CD4A00   [17]     lupc1:call	rdvrm			; get first grid character
BD15: DD21A5C5 [31]     	ld	ix,editwork+1
BD19: DD9E00   [50]     	sbc	a,(ix)		; subtract from empty one index (bigger)
BD1C: CB11     [58]     	rl	c			; rotate left, put carry result on bit 0
BD1E: 23       [64]     	inc	hl			; increment columns/bits
BD1F: 10F1     [72|77]  	djnz	lupc1			; do until no more columns/bits
BD21: 79       [76]     	ld	a,c			; get resulting byte on A
BD22: EB       [80]     	ex	hl,de			; get character pattern address
BD23: CD4D00   [97]     	call	wrtvrm		; write created byte
BD26: 23       [103]    	inc	hl			; increment pattern byte
BD27: EB       [107]    	ex	hl,de			; get grid address back
BD28: D5       [118]    	push	de			; save pattern address
BD29: 111800   [128]    	ld	de,0x18		; get amount to next row
BD2C: 19       [139]    	add	hl,de			; add to grid screen address
BD2D: D1       [149]    	pop	de			; get character pattern address back
BD2E: C1       [159]    	pop	bc			; restore rows/bytes counter
BD2F: 0D       [163]    	dec	c			; decrement
BD30: 20DF     [170|175]	jr	nz,lupc2		; loop until no more rows/bytes
BD32: C9       [180]    	ret
                        
BD33:                   drawgrid:				; draw the editing grid with the character
                        					; input: A=character
BD33: 215518   [10]     	ld	hl,0x1855		; get editing char position
BD36: CD4D00   [27]     	call	wrtvrm		; write to screen
                        					; get character pattern VRAM address
BD39: 2600     [34]     	ld	h,0x00		; put character index in HL
BD3B: 6F       [38]     	ld	l,a			;
BD3C: 29       [49]     	add	hl,hl			; multiply by 8 to get the pattern
BD3D: 29       [60]     	add	hl,hl			;
BD3E: 29       [71]     	add	hl,hl			;
BD3F: 54       [75]     	ld	d,h			; put in DE
BD40: 5D       [79]     	ld	e,l			;
BD41: 219518   [89]     	ld	hl,0x1895		; grid top left screen pos
BD44: 0E08     [96]     	ld	c,0x08		; grid rows/bytes length
                        					; rows/bytes
BD46: EB       [ 4]     lgrd1:ex	de,hl			; put the pattern address in HL
BD47: CD4A00   [21]     	call	rdvrm			; get it
BD4A: EB       [25]     	ex	de,hl			; put back in DE
BD4B: 0608     [32]     	ld	b,0x08		; grid columns/bits length
                        					; columns/bits
BD4D: 17       [ 4]     lgrd2:rla				; put the left bit on the carrier
BD4E: F5       [15]     	push	af			; save the byte being read
BD4F: 3815     [22|27]  	jr	c,sgrd2		; if the bit is 1, get ON char
BD51: 3AA5C5   [35]     	ld	a,(editwork+1)	; else get the OFF character
BD54: CD4D00   [17]     sgrd1:call	wrtvrm		; put it on the screen
BD57: F1       [27]     	pop	af			; get the byte being read back
BD58: 23       [33]     	inc	hl			; increment grid column
BD59: 10F2     [41|46]  	djnz	lgrd2			; do until the byte is finished
BD5B: 13       [47]     	inc	de			; increment to next pattern byte
BD5C: D5       [58]     	push	de			; save the pattern address
BD5D: 111800   [68]     	ld	de,0x18		; get amount to next row position
BD60: 19       [79]     	add	hl,de			; add to current position
BD61: D1       [89]     	pop	de			; get back the pattern address
BD62: 0D       [93]     	dec	c			; decrement rows/bytes counter
BD63: 20E1     [100|105]	jr	nz,lgrd1		; do while there are rows/bytes
BD65: C9       [110]    	ret
BD66: 3AA4C5   [13]     sgrd2:ld	a,(editwork)	; get ON character
BD69: 18E9     [25]     	jr	sgrd1			; return
                        
BD6B:                   testmaparea:			; test if cursor inside the char map area
BD6B: 3A2DC4   [13]     	ld	a,(curat)		; get cursor y pos
BD6E: FE1C     [20]     	cp	0x1c			; compare with top position
BD70: 3811     [27|32]  	jr	c,stma1		; if lower, jump
BD72: FE9C     [34]     	cp	0x9c			; compare with bottom position
BD74: 300D     [41|46]  	jr	nc,stma1		; if higher, jump
BD76: 3A2EC4   [54]     	ld	a,(curat+1)		; get cursor x pos
BD79: FE14     [61]     	cp	0x14			; compare with left position
BD7B: 3806     [68|73]  	jr	c,stma1		; if lower, jump
BD7D: FE94     [75]     	cp	0x94			; compare with right position
BD7F: 3002     [82|87]  	jr	nc,stma1		; if higher, jump
BD81: 37       [86]     	scf				; set carrier flag
BD82: C9       [96]     	ret
BD83: 37       [ 4]     stma1:scf				; set carrier flag
BD84: 3F       [ 8]     	ccf				; invert carrier flag
BD85: C9       [18]     	ret
                        
BD86:                   testgridrea:			; test if cursor inside the grid ares
                        					; check if inside grid
BD86: 3A2DC4   [13]     	ld	a,(curat)		; get cursor y pos
BD89: FE1C     [20]     	cp	0x1c			; compare with top position
BD8B: 3811     [27|32]  	jr	c,stga1		; if lower, jump
BD8D: FE5C     [34]     	cp	0x5c			; compare with bottom position
BD8F: 300D     [41|46]  	jr	nc,stga1		; if higher, jump
BD91: 3A2EC4   [54]     	ld	a,(curat+1)		; get cursor x pos
BD94: FEA4     [61]     	cp	0xa4			; compare with left position
BD96: 3806     [68|73]  	jr	c,stga1		; if lower, jump
BD98: FEE4     [75]     	cp	0xe4			; compare with right position
BD9A: 3002     [82|87]  	jr	nc,stga1		; if higher, jump
BD9C: 37       [86]     	scf				; set carrier flag
BD9D: C9       [96]     	ret
BD9E: 37       [ 4]     stga1:scf				; set carrier flag
BD9F: 3F       [ 8]     	ccf				; invert carrier flag
BDA0: C9       [18]     	ret
                        
BDA1:                   getchrfromarea:			; get character depending if on grid or map
BDA1: CD6BBD   [17]     	call	testmaparea		; test if inside the char map
BDA4: 3A37C4   [30]     	ld	a,(edtch)		; get the current character
BDA7: D0       [35|41]  	ret	nc			; if not inside the char map, skip
BDA8: 2A2DC4   [51]     	ld	hl,(curat)		; get the cursor xy position
BDAB: CD10C4   [68]     	call	vrampos		; get the cursor VRAM address
BDAE: CD4A00   [85]     	call	rdvrm			; read it
BDB1: C9       [95]     	ret
                        
                        
BDB2:                   edtrollchar:			; cycle current character
BDB2: CD86BD   [17]     	call	testgridrea		; is inside the grid?
BDB5: D0       [22|28]  	ret	nc			; if not, return
BDB6: 3A37C4   [35]     	ld	a,(edtch)		; get the current character from variable
BDB9: 80       [39]     	add	a,b			; add offset
BDBA: 3237C4   [52]     	ld	(edtch),a		; put back at variable
BDBD: CDCABD   [69]     	call	edtsetundo		; copy char to undo buffer
BDC0: 3A37C4   [82]     	ld	a,(edtch)		; get editing character
BDC3: CD33BD   [99]     	call	drawgrid		; draw the grid
BDC6: CD5601   [116]    	call	kilbuf		; clear keyboard buffer
BDC9: C9       [126]    	ret
                        
BDCA:                   edtsetundo:				; save character to undo buffer
                        					; copy pattern to undo buffer
BDCA: 3A37C4   [13]     	ld	a,(edtch)		; get editing character
BDCD: CDB6BE   [30]     	call	getpatternad	; get pattern address
BDD0: 1151C4   [40]     	ld	de,edtundoch	; get RAM undo buffer address
BDD3: 010800   [50]     	ld	bc,0x08		; get char length
BDD6: CD5900   [67]     	call	ldirmv		; save in undo buffer
                        					; copy color to undo buffer
BDD9: 3A37C4   [80]     	ld	a,(edtch)		; get editing character
BDDC: CDA9BE   [97]     	call	getcolorfrchr	; get its color address
BDDF: 1159C4   [107]    	ld	de,edtundocl	; get undo buffer
BDE2: 010100   [117]    	ld	bc,0x01		; length of 1 byte (ready for hi color mode)
BDE5: CD5900   [134]    	call	ldirmv		; copy
BDE8: CD5601   [151]    	call	kilbuf
BDEB: C9       [161]    	ret
                        
BDEC:                   edtundo:				; undo last character modifications
                        					; undo color
BDEC: 3A37C4   [13]     	ld	a,(edtch)		; get editing character
BDEF: CDA9BE   [30]     	call	getcolorfrchr	; get its color address
BDF2: 54       [34]     	ld	d,h			; put in DE
BDF3: 5D       [38]     	ld	e,l 			;
BDF4: 2159C4   [48]     	ld	hl,edtundocl	; get undo buffer address
BDF7: 010100   [58]     	ld	bc,0x01		; length of 1 byte (ready for hi color mode)
BDFA: CD5C00   [75]     	call	ldirvm		; copy
                        					; undo pattern
BDFD: 3A37C4   [88]     	ld	a,(edtch)		; get editing character
BE00: CDB6BE   [105]    	call	getpatternad	; get its pattern address
BE03: 2151C4   [115]    	ld	hl,edtundoch	; get the undo buffer address
BE06: 010800   [125]    	ld	bc,0x08		; whole character
BE09: CD5C00   [142]    	call	ldirvm		; copy
BE0C: 3A37C4   [155]    	ld	a,(edtch)		; get editing character
BE0F: CD33BD   [172]    	call	drawgrid		; draw editing grid
BE12: CD5601   [189]    	call	kilbuf		; clear keyboard buffer 
BE15: C9       [199]    	ret
                        
BE16:                   edtcopy:				; copy character pattern and color
BE16: CDA1BD   [17]     	call	getchrfromarea	; get caracter according to area
                        					; copy color
BE19: F5       [11]     seco1:push	af			; save the character
BE1A: CDA9BE   [28]     	call	getcolorfrchr	; get its color address
BE1D: 1149C4   [38]     	ld	de,edtcopycl	; get copy buffer address
BE20: 010100   [48]     	ld	bc,0x01		; length of 1 byte (ready for hi color mode)
BE23: CD5900   [65]     	call	ldirmv		; copy
                        					; copy pattern
BE26: F1       [75]     	pop	af			; restore the character
BE27: CDB6BE   [92]     	call	getpatternad	; get its pattern address
BE2A: 1141C4   [102]    	ld	de,edtcopych	; get the copy buffer address
BE2D: 010800   [112]    	ld	bc,0x08		; whole character
BE30: CD5900   [129]    	call	ldirmv		; copy
BE33: CD5601   [146]    	call	kilbuf		; clear keyboard buffer 
BE36: C9       [156]    	ret
                        
BE37:                   edtpaste:				; paste character pattern and color
BE37: CDA1BD   [17]     	call	getchrfromarea	; get caracter according to area
BE3A: F5       [11]     sepa3:push	af			; save the character
BE3B: 05       [15]     	dec	b			; decrement paste type byte
BE3C: C5       [26]     	push	bc			; save paste type
BE3D: 280E     [33|38]  	jr	z,sepa1		; if zero skip color	
                        					; paste color
BE3F: CDA9BE   [50]     	call	getcolorfrchr	; get its color address
BE42: 54       [54]     	ld	d,h			; put in DE
BE43: 5D       [58]     	ld	e,l 			;
BE44: 2149C4   [68]     	ld	hl,edtcopycl	; get copy buffer address
BE47: 010100   [78]     	ld	bc,0x01		; length of 1 byte (ready for hi color mode)
BE4A: CD5C00   [95]     	call	ldirvm		; copy
BE4D: C1       [10]     sepa1:pop	bc			; restore paste byte
BE4E: F1       [20]     	pop	af			; restore the character
BE4F: 05       [24]     	dec	b			; decrement paste type byte
BE50: 280C     [31|36]  	jr	z,sepa2		; if zero skip to end
                        					; paste pattern
BE52: CDB6BE   [48]     	call	getpatternad	; get its pattern address
BE55: 2141C4   [58]     	ld	hl,edtcopych	; get the copy buffer address
BE58: 010800   [68]     	ld	bc,0x08		; whole character
BE5B: CD5C00   [85]     	call	ldirvm		; copy
BE5E: CD6BBD   [17]     sepa2:call	testmaparea		; test if inside the char map
BE61: 3806     [24|29]  	jr	c,sepa4		; if it is skip draw grid
BE63: 3A37C4   [37]     	ld	a,(edtch)		; get editing character
BE66: CD33BD   [54]     	call	drawgrid		; draw editing grid
BE69: CD5601   [17]     sepa4:call	kilbuf		; clear keyboard buffer 
BE6C: C9       [27]     	ret
                        
BE6D:                   edtforecolor:			; edit a character block foreground color
BE6D: CDA1BD   [17]     	call	getchrfromarea	; get caracter according to area
BE70: CDA9BE   [17]     sefc1:call	getcolorfrchr	; get its full color (fore and back)
BE73: F5       [28]     	push	af			; save it
BE74: CB3F     [36]     	srl	a			; send high nibble to the low position
BE76: CB3F     [44]     	srl	a			; 
BE78: CB3F     [52]     	srl	a			;
BE7A: CB3F     [60]     	srl	a			;
BE7C: 80       [64]     	add	a,b			; add with offset
BE7D: CB37     [72]     	sll	a			; send low nibble to the high position
BE7F: CB37     [80]     	sll	a			;
BE81: CB37     [88]     	sll	a			;
BE83: CB37     [96]     	sll	a			;
BE85: E6F0     [103]    	and	0b11110000		; discard the low nibble
BE87: 47       [107]    	ld	b,a			; put in B
BE88: F1       [117]    	pop	af			; restore full color
BE89: E60F     [124]    	and	0b00001111		; discard original high nibble
BE8B: B0       [128]    	or	b			; mix with new high nibble
BE8C: CD4D00   [145]    	call	wrtvrm		; write it
BE8F: CD5601   [162]    	call	kilbuf		; clear keyboard buffer
BE92: C9       [172]    	ret
                        
BE93:                   edtbackcolor:			; edit a character b
BE93: CDA1BD   [17]     	call	getchrfromarea	; get caracter according to area
BE96: CDA9BE   [17]     sebc1:call	getcolorfrchr	; get its full color (fore and back)
BE99: F5       [28]     	push	af			; save it
BE9A: 80       [32]     	add	a,b			; add with offset
BE9B: E60F     [39]     	and	0b00001111		; discard high nibble
BE9D: 47       [43]     	ld	b,a			; put in B
BE9E: F1       [53]     	pop	af			; restore full color
BE9F: E6F0     [60]     	and	0b11110000		; discard original low nibble
BEA1: B0       [64]     	or	b			; mix with new low nibble
BEA2: CD4D00   [81]     	call	wrtvrm		; write it
BEA5: CD5601   [98]     	call	kilbuf		; clear keyboard buffer
BEA8: C9       [108]    	ret
                        
BEA9:                   getcolorfrchr:			; get character color from VRAM table
                        					; input: A=character
                        					; output: A=color:HL=address
BEA9: CB3F     [ 8]     	srl	a			; divide by 2
BEAB: CB3F     [16]     	srl	a			; divide by 4
BEAD: CB3F     [24]     	srl	a			; divide by 8
BEAF: 2620     [31]     	ld	h,0x20		; H=high VRAM color table byte
BEB1: 6F       [35]     	ld	l,a			; L=low VRAM color table byte
BEB2: CD4A00   [52]     	call	rdvrm			; read color to A
BEB5: C9       [62]     	ret
                        
BEB6:                   getpatternad:			; get the pattern address of a character
                        					; input: A=character
                        					; output: HL,DE=address
BEB6: 2600     [ 7]     	ld	h,0x00		; put character index in HL
BEB8: 6F       [11]     	ld	l,a			;
BEB9: 29       [22]     	add	hl,hl			; multiply by 8 to get the pattern
BEBA: 29       [33]     	add	hl,hl			;
BEBB: 29       [44]     	add	hl,hl			;
BEBC: 54       [48]     	ld	d,h			; put in DE
BEBD: 5D       [52]     	ld	e,l			;
BEBE: C9       [62]     	ret
                        
BEBF:                   edtinit:				; get editing char and pattern address
                        					; common header for the editing routines
BEBF: CDA1BD   [17]     	call	getchrfromarea	; get caracter according to area
BEC2: CDB6BE   [34]     	call	getpatternad	; get its pattern address
BEC5: C9       [44]     	ret
                        
BEC6:                   edtfnish:				; get editing char and update the grid
                        					; common footer for the editing routines
BEC6: 3A37C4   [13]     	ld	a,(edtch)		; get editing character
BEC9: CD33BD   [30]     	call	drawgrid		; draw the grid
BECC: CD5601   [47]     	call	kilbuf		; clear keyboard buffer
BECF: C9       [57]     	ret
                        
BED0:                   edtinvert:				; invert grid
BED0: CDBFBE   [17]     	call	edtinit		; get editing char and pattern address
BED3: 0608     [24]     	ld	b,0x08		; set length to whole character
BED5: CD4A00   [17]     leinv:call	rdvrm			; read pattern address byte
BED8: 2F       [21]     	cpl				; invert it
BED9: CD4D00   [38]     	call	wrtvrm		; write it back
BEDC: 23       [44]     	inc	hl			; increment pattern address
BEDD: 10F6     [52|57]  	djnz	leinv			; repeat until done
BEDF: CDC6BE   [69]     	call	edtfnish		; draw the grid with editing char
BEE2: C9       [79]     	ret
                        
BEE3:                   edtcheckb:
BEE3: CDBFBE   [17]     	call	edtinit		; get editing char and pattern address
BEE6: 0604     [24]     	ld	b,0x04		; set length to half character
BEE8: 3EAA     [ 7]     leckbd:ld	a,0xaa		; create even pattern
BEEA: CD4D00   [24]     	call	wrtvrm		; write it
BEED: 23       [30]     	inc	hl			; increment pattern address
BEEE: 3E55     [37]     	ld	a,0x55		; create odd pattern
BEF0: CD4D00   [54]     	call	wrtvrm		; write it
BEF3: 23       [60]     	inc	hl			; increment pattern address
BEF4: 10F2     [68|73]  	djnz	leckbd		; repeat until done
BEF6: CDC6BE   [85]     	call	edtfnish		; draw the grid with editing char
BEF9: C9       [95]     	ret
                        
BEFA:                   edtfill:				; fill grid
BEFA: CDBFBE   [17]     	call	edtinit		; get editing char and pattern address
BEFD: 010800   [27]     	ld	bc,0x08		; set length to whole character
BF00: 3EFF     [34]     	ld	a,0xff		; set all bits
BF02: CD5600   [51]     	call	filvrm		; fill editing character
BF05: CDC6BE   [68]     	call	edtfnish		; draw the grid with editing char
BF08: C9       [78]     	ret
                        
BF09:                   edtclear:				; clear grid
BF09: CDBFBE   [17]     	call	edtinit		; get editing char and pattern address
BF0C: 010800   [27]     	ld	bc,0x08		; set length to whole character
BF0F: 3E00     [34]     	ld	a,0x00		; reset all bits
BF11: CD5600   [51]     	call	filvrm		; fill editing character
BF14: CDC6BE   [68]     	call	edtfnish		; draw the grid with editing char
BF17: C9       [78]     	ret
                        
BF18:                   edtscrlft:				; scroll grid left
BF18: CDBFBE   [17]     	call	edtinit		; get editing char and pattern address
BF1B: 0608     [24]     	ld	b,0x08		; set length to whole character
BF1D: CD4A00   [17]     lescl:call	rdvrm			; get first pattern byte
BF20: CB07     [25]     	rlc	a			; rotate bits left
BF22: CD4D00   [42]     	call	wrtvrm		; write it back
BF25: 23       [48]     	inc	hl			; go to next byte
BF26: 10F5     [56|61]  	djnz	lescl			; do until finished
BF28: CDC6BE   [73]     	call	edtfnish		; draw the grid with editing char
BF2B: C9       [83]     	ret
                        
BF2C:                   edtscrlrgt:				; scroll grid right
BF2C: CDBFBE   [17]     	call	edtinit		; get editing char and pattern address
BF2F: 0608     [24]     	ld	b,0x08		; set length to whole character
BF31: CD4A00   [17]     lescr:call	rdvrm			; get first pattern byte
BF34: CB0F     [25]     	rrc	a			; rotate bits right
BF36: CD4D00   [42]     	call	wrtvrm		; write it back
BF39: 23       [48]     	inc	hl			; go to next byte
BF3A: 10F5     [56|61]  	djnz	lescr			; do until finished
BF3C: CDC6BE   [73]     	call	edtfnish		; draw the grid with editing char
BF3F: C9       [83]     	ret
                        
BF40:                   edtscrup:				; scroll grid up
BF40: CDBFBE   [17]     	call	edtinit		; get editing char and pattern address
BF43: CD4A00   [34]     	call	rdvrm			; get first pattern byte
BF46: 23       [40]     	inc	hl			; goto next byte
BF47: 010700   [50]     	ld	bc,0x07		; set length of 7 bytes
BF4A: CD0BC3   [67]     	call	streamvv		; copy the lower byte to the higher byte
BF4D: 2B       [73]     	dec	hl			; go back to the last byte
BF4E: CD4D00   [90]     	call	wrtvrm		; write first pattern byte on last address
BF51: CDC6BE   [107]    	call	edtfnish		; draw the grid with editing char
BF54: C9       [117]    	ret
                        
BF55:                   edtscrdwn:				; scroll grid down
BF55: CDBFBE   [17]     	call	edtinit		; get editing char and pattern address
BF58: 110700   [27]     	ld	de,0x07		; set for the last (7th) byte
BF5B: 19       [38]     	add	hl,de			; add it to the pattern address
BF5C: 0607     [45]     	ld	b,0x07		; set length of 7 bytes
BF5E: CD4A00   [62]     	call	rdvrm			; get the last (7th) byte
BF61: F5       [73]     	push	af			; save it
BF62: 2B       [ 6]     lescd:dec	hl			; decrement patter address
BF63: CD4A00   [23]     	call	rdvrm			; get pattern
BF66: 23       [29]     	inc	hl			; increment patter address
BF67: CD4D00   [46]     	call	wrtvrm		; write pattern
BF6A: 2B       [52]     	dec	hl			; decrement pattern address
BF6B: 10F5     [60|65]  	djnz	lescd			; repeat until finished
BF6D: F1       [70]     	pop	af			; restore last pattern byte
BF6E: CD4D00   [87]     	call	wrtvrm		; write on first address
BF71: CDC6BE   [104]    	call	edtfnish		; draw the grid with editing char
BF74: C9       [114]    	ret
                        
BF75:                   edtflipvrt:				; flip grid vertically
BF75: CDBFBE   [17]     	call	edtinit		; get editing char and pattern address
BF78: 0E08     [24]     	ld	c,0x08		; rows/bytes length
BF7A: 0608     [ 7]     lefv2:ld	b,0x08		; columns/bits length
BF7C: CD4A00   [24]     	call	rdvrm			; read pattern
BF7F: 57       [28]     	ld	d,a			; save to D
BF80: CB12     [ 8]     lefv1:rl	d			; rotate its bits left and put on the carrier
BF82: 1F       [12]     	rra				; put the carrier on the A right bit
BF83: 10FB     [20|25]  	djnz	lefv1			; repeat until all columns/bits are done
BF85: CD4D00   [37]     	call	wrtvrm		; write it back
BF88: 23       [43]     	inc	hl			; go to next pattern byte
BF89: 0D       [47]     	dec	c			; decrement rows/bytes counter
BF8A: 20EE     [54|59]  	jr	nz,lefv2		; do until all rows/bytes are done
BF8C: CDC6BE   [71]     	call	edtfnish		; draw the grid with editing char
BF8F: C9       [81]     	ret
                        
BF90:                   edtfliphrz:				; flip grid horizontally
BF90: CDBFBE   [17]     	call	edtinit		; get editing char and pattern address
BF93: D5       [28]     	push	de			; save pattern address
BF94: 0608     [35]     	ld	b,0x08		; set rows/ bytes counter
BF96: 1140C4   [45]     	ld	de,edthelpch+7	; get the temp char last (7th) pattern address
BF99: CD4A00   [17]     lefh1:call	rdvrm			; read the first editing char pattern address
BF9C: 12       [24]     	ld	(de),a		; put first editing byte on last temp byte
BF9D: 23       [30]     	inc	hl			; increment editing
BF9E: 1B       [36]     	dec	de			; decrement temp
BF9F: 10F8     [44|49]  	djnz	lefh1			; do until character finished
BFA1: 2139C4   [54]     	ld	hl,edthelpch	; get address of temp character
BFA4: D1       [64]     	pop	de			; restore address of editing char pattern
BFA5: 010800   [74]     	ld	bc,0x08		; set the length to all character
BFA8: CD5C00   [91]     	call	ldirvm		; copy temp character to editing character
BFAB: CDC6BE   [108]    	call	edtfnish		; draw the grid with editing char
BFAE: C9       [118]    	ret
                        
BFAF:                   edtrotrgt:				; rotate grid right
BFAF: CDBFBE   [17]     	call	edtinit		; get editing char and pattern address
BFB2: 0E08     [24]     	ld	c,0x08		; set rows/bytes counter
BFB4: 0608     [ 7]     lerr1:ld	b,0x08		; set columns/bits counter
BFB6: E5       [18]     	push	hl			; save editing char pattern address
BFB7: CD4A00   [35]     	call	rdvrm			; read pattern byte
BFBA: 2139C4   [45]     	ld	hl,edthelpch	; get temp char pattern address 
BFBD: 17       [ 4]     lerr2:rla				; rotate editing char pttrn byte left and get carrier
BFBE: CB1E     [19]     	rr	(hl)			; rotate right temp char pttrn byte inserting carrier 
BFC0: 23       [25]     	inc	hl			; increment temp char pattern byte
BFC1: 10FA     [33|38]  	djnz	lerr2			; repeat until finished
BFC3: E1       [43]     	pop	hl			; restore editing char pattern address
BFC4: 23       [49]     	inc	hl			; increment it
BFC5: 0D       [53]     	dec	c			; decrement rows/bytes counter
BFC6: 20EC     [60|65]  	jr	nz,lerr1		; repeat until finished
BFC8: 2139C4   [70]     	ld	hl,edthelpch	; get temp char pattern address
BFCB: 010800   [80]     	ld	bc,0x08		; set length to whole character
BFCE: CD5C00   [97]     	call	ldirvm		; put on editing character
BFD1: CDC6BE   [114]    	call	edtfnish		; draw the grid with editing char
BFD4: C9       [124]    	ret
                        
BFD5:                   edtrotlft:				; rotate grid left
BFD5: CDBFBE   [17]     	call	edtinit		; get editing char and pattern address
BFD8: 0E08     [24]     	ld	c,0x08		; set rows/bytes counter
BFDA: 0608     [ 7]     lerl1:ld	b,0x08		; set columns/bits counter
BFDC: E5       [18]     	push	hl			; save editing char pattern address
BFDD: CD4A00   [35]     	call	rdvrm			; read pattern byte
BFE0: 2139C4   [45]     	ld	hl,edthelpch	; get temp char pattern address 
BFE3: 1F       [ 4]     lerl2:rra				; rotate editing char pttrn byte right and get carrier
BFE4: CB16     [19]     	rl	(hl)			; rotate left temp char pttrn byte inserting carrier 
BFE6: 23       [25]     	inc	hl			; increment temp char pattern byte
BFE7: 10FA     [33|38]  	djnz	lerl2			; repeat until finished
BFE9: E1       [43]     	pop	hl			; restore editing char pattern address
BFEA: 23       [49]     	inc	hl			; increment it
BFEB: 0D       [53]     	dec	c			; decrement rows/bytes counter
BFEC: 20EC     [60|65]  	jr	nz,lerl1		; repeat until finished
BFEE: 2139C4   [70]     	ld	hl,edthelpch	; get temp char pattern address
BFF1: 010800   [80]     	ld	bc,0x08		; set length to whole character
BFF4: CD5C00   [97]     	call	ldirvm		; put on editing character
BFF7: CDC6BE   [114]    	call	edtfnish		; draw the grid with editing char
BFFA: C9       [124]    	ret
                        #include "masciiKB.asm"		; keyboard reading
                        ; ------------------KEYBOARD READ
                        
BFFB:                   readgenkeys:
BFFB: 3AEBFB   [13]     	ld	a,(NEWKEY+6)	; keyboard matrix: F3 F2 F1 CODE CAPS GRAPH CTRL SHIFT
BFFE: 57       [17]     	ld	d,a			; store in d
                        
BFFF: 3AE7FB   [30]     	ld	a,(NEWKEY+2)	; keyboard matrix: B A DEAD /? .> ,< `~ '"
C002: FEFF     [37]     	cp	0xff			; pressed key on this row?
C004: 281C     [44|49]  	jr	z,ngek2		; if not, jump to next
C006: A2       [48]     	and	d			; combine with alt keys result
C007: 0600     [55]     	ld	b,0x00		; filled rectangle
C009: FE7F     [62]     	cp	0b01111111		; b
C00B: CAC0B7   [72|72]  	jp	z,preparerect
C00E: FEBF     [79]     	cp	0b10111111		; a
C010: CA45B6   [89|89]  	jp	z,scrollleft
C013: FEEE     [96]     	cp	0b11101110		; / + SHIFT
C015: CAECB2   [106|106]	jp	z,getcharkey
C018: FEEF     [113]    	cp	0b11101111		; /
C01A: CADEB1   [123|123]	jp	z,showcharmap
C01D: FEF7     [130]    	cp	0b11110111		; .
C01F: CA37BB   [140|140]	jp	z,showeditchrscr
C022:                   ngek2:
C022: 3AE8FB   [13]     	ld	a,(NEWKEY+3)	; keyboard matrix: J I H G F E D C
C025: FEFF     [20]     	cp	0xff			; pressed key on this row?
C027: 282A     [27|32]  	jr	z,ngek3		; if not, jump to next
C029: A2       [31]     	and	d			; combine with alt keys result
C02A: FEBF     [38]     	cp	0b10111111		; i
C02C: CA9AB1   [48|48]  	jp	z,fileinput
C02F: FEDF     [55]     	cp	0b11011111		; h
C031: CA54B3   [65|65]  	jp	z,showhelp
C034: FEF7     [72]     	cp	0b11110111		; f
C036: CA83B5   [82|82]  	jp	z,swapbuffers
C039: 0600     [89]     	ld	b,0x00		; don't flip patterns
C03B: FEFB     [96]     	cp	0b11111011		; e
C03D: CAC0B6   [106|106]	jp	z,flipscrhorz
C040: 0601     [113]    	ld	b,0x01		; flip patterns
C042: FEFA     [120]    	cp	0b11111010		; e + SHIFT
C044: CAC0B6   [130|130]	jp	z,flipscrhorz
C047: FEFD     [137]    	cp	0b11111101		; d
C049: CA27B6   [147|147]	jp	z,scrollright
C04C: 0605     [154]    	ld	b,0x05		; copy area rectangle type
C04E: FEFE     [161]    	cp	0b11111110		; c
C050: CAC0B7   [171|171]	jp	z,preparerect
C053:                   ngek3:
C053: 3AE9FB   [13]     	ld	a,(NEWKEY+4)	; keyboard matrix: R Q P O N M L K
C056: FEFF     [20]     	cp	0xff			; pressed key on this row?
C058: 281E     [27|32]  	jr	z,ngek4		; if not, jump to next
C05A: A2       [31]     	and	d			; combine with alt keys result
C05B: 0600     [38]     	ld	b,0x00		; don't flip patterns
C05D: FEBF     [45]     	cp	0b10111111		; q
C05F: CA73B6   [55|55]  	jp	z,flipscrvert
C062: 0601     [62]     	ld	b,0x01		; flip patterns
C064: FEBE     [69]     	cp	0b10111110		; q + SHIFT
C066: CA73B6   [79|79]  	jp	z,flipscrvert
C069: FEBD     [86]     	cp	0b10111101		; q + CTRL
C06B: CAC6B1   [96|96]  	jp	z,setquit
C06E: FEEF     [103]    	cp	0b11101111		; o
C070: CAB0B1   [113|113]	jp	z,fileoutput
C073: FEF7     [120]    	cp	0b11110111		; n
C075: CACCB4   [130|130]	jp	z,pickchar
C078:                   ngek4:
C078: 3AEAFB   [13]     	ld	a,(NEWKEY+5)	; keyboard matrix: Z Y X W V U T S
C07B: FEFF     [20]     	cp	0xff			; pressed key on this row?
C07D: 283B     [27|32]  	jr	z,ngek5		; if not, jump to next
C07F: A2       [31]     	and	d			; combine with alt keys result
C080: 06F1     [38]     	ld	b,0xf1		; -16 chracters
C082: FE7E     [45]     	cp	0b01111110		; z + SHIFT
C084: CABBB4   [55|55]  	jp	z,rollchar
C087: 06FF     [62]     	ld	b,0xff		; -1 character
C089: FE7F     [69]     	cp	0b01111111		; z
C08B: CABBB4   [79|79]  	jp	z,rollchar
C08E: FEBF     [86]     	cp	0b10111111		; y
C090: CAC4C2   [96|96]  	jp	z,setundo
C093: 060F     [103]    	ld	b,0x0f		; +16 chracters
C095: FEDE     [110]    	cp	0b11011110		; x + SHIFT
C097: CABBB4   [120|120]	jp	z,rollchar
C09A: 0601     [127]    	ld	b,0x01		; +1 character
C09C: FEDF     [134]    	cp	0b11011111		; x
C09E: CABBB4   [144|144]	jp	z,rollchar
C0A1: FEEF     [151]    	cp	0b11101111		; w
C0A3: CAE9B5   [161|161]	jp	z,scrollup
C0A6: FEF7     [168]    	cp	0b11110111		; v
C0A8: CA3CB9   [178|178]	jp	z,pasteoldbuf
C0AB: FEFB     [185]    	cp	0b11111011		; u
C0AD: CA76B5   [195|195]	jp	z,undolast
C0B0: FEFD     [202]    	cp	0b11111101		; t
C0B2: CAB8B2   [212|212]	jp	z,entertext
C0B5: FEFE     [219]    	cp	0b11111110		; s
C0B7: CA08B6   [229|229]	jp	z,scrolldown
C0BA:                   ngek5:
C0BA: 3AECFB   [13]     	ld	a,(NEWKEY+7)	; keyboard matrix: RET SELECT BS STOP TAB ESC F5 F4
C0BD: FEFF     [20]     	cp	0xff			; pressed key on this row?
C0BF: 281A     [27|32]  	jr	z,ngek7		; if not, jump to next
C0C1: A2       [31]     	and	d			; combine with alt keys result
C0C2: FE7F     [38]     	cp	0b01111111		; ENTER
C0C4: CAA1B4   [48|48]  	jp	z,drawchar
C0C7: FEDF     [55]     	cp	0b11011111		; BS
C0C9: CAAEB4   [65|65]  	jp	z,erasechar
C0CC: FEFB     [72]     	cp	0b11111011		; ESC
C0CE: CA9BB5   [82|82]  	jp	z,clearscr
C0D1: FEFA     [89]     	cp	0b11111010		; ESC + SHIFT
C0D3: CAAFB5   [99|99]  	jp	z,clearscrchar
C0D6: FEF9     [106]    	cp	0b11111001		; ESC + CTRL
C0D8: CACCB5   [116|116]	jp	z,clearscrinit
C0DB:                   ngek7:
C0DB: C9       [10]     	ret				; if no key found return without killing buffer
                        
C0DC:                   readmainkeys:
C0DC: 3AEBFB   [13]     	ld	a,(NEWKEY+6)	; keyboard matrix: F3 F2 F1 CODE CAPS GRAPH CTRL SHIFT
C0DF: 57       [17]     	ld	d,a			; store in d
                        
C0E0: 3AE5FB   [30]     	ld	a,(NEWKEY+0)	; keyboard matrix: 7& 6^ 5% 4$ 3# 2@ 1! 0)
C0E3: FEFF     [37]     	cp	0xff			; pressed key on this row?
C0E5: 280E     [44|49]  	jr	z,nmak0		; if not, jump to next
C0E7: 06FF     [51]     	ld	b,0xff		; decrease color
C0E9: FE7F     [58]     	cp	0b01111111		; 7
C0EB: CA4DB5   [68|68]  	jp	z,cursorcolor
C0EE: 0601     [75]     	ld	b,0x01		; increase color
C0F0: FEFE     [82]     	cp	0b11111110		; 0
C0F2: CA90B5   [92|92]  	jp	z,cyclebordcol
C0F5:                   nmak0:
C0F5: 3AE6FB   [13]     	ld	a,(NEWKEY+1)	; keyboard matrix: ;: ]} [{ \¦ =+ -_ 9( 8*
C0F8: FEFF     [20]     	cp	0xff			; pressed key on this row?
C0FA: 280E     [27|32]  	jr	z,nmak1		; if not, jump to next
C0FC: 06FF     [34]     	ld	b,0xff		; decrease color
C0FE: FEFD     [41]     	cp	0b11111101		; 9
C100: CA90B5   [51|51]  	jp	z,cyclebordcol
C103: 0601     [58]     	ld	b,0x01		; increase color
C105: FEFE     [65]     	cp	0b11111110		; 8
C107: CA4DB5   [75|75]  	jp	z,cursorcolor
C10A:                   nmak1:
                        	; ld	a,(NEWKEY+3)	; keyboard matrix: J I H G F E D C
                        	; cp	0xff			; pressed key on this row?
                        	; jr	z,nmak3		; if not, jump to next
                        	; rlca
                        	; and	d			; combine with alt keys result
                        ; nmak3:
C10A: 3AE9FB   [13]     	ld	a,(NEWKEY+4)	; keyboard matrix: R Q P O N M L K
C10D: FEFF     [20]     	cp	0xff			; pressed key on this row?
C10F: 2807     [27|32]  	jr	z,nmak4		; if not, jump to next
C111: 0640     [34]     	ld	b,0b01000000	; flip bit 6
C113: FEFB     [41]     	cp	0b11111011		; m
C115: CAE9C3   [51|51]  	jp	z,toggleflags
C118:                   nmak4:
C118: 3AEDFB   [13]     	ld	a,(NEWKEY+8)	; keyboard matrix: → ↓ ↑ ← DEL INS HOME SPACE
C11B: FEFF     [20]     	cp	0xff			; pressed key on this row?
C11D: 2833     [27|32]  	jr	z,nmak8		; if not, jump to next
C11F: F601     [34]     	or	0b00000001		; mask SPACE to avoid conflict with SHIFT
C121: A2       [38]     	and	d			; combine with alt keys result
C122: 0620     [45]     	ld	b,0x20		; +32 pixels (4 char)
C124: FE7E     [52]     	cp	0b01111110		; → + SHIFT
C126: CA45B7   [62|62]  	jp	z,movcurhor
C129: FEBE     [69]     	cp	0b10111110		; ↓ + SHIFT
C12B: CA51B7   [79|79]  	jp	z,movcurver
C12E: 06E0     [86]     	ld	b,0xe0		; -32 pixels (4 char)
C130: FEDE     [93]     	cp	0b11011110		; ↑ + SHIFT
C132: CA51B7   [103|103]	jp	z,movcurver
C135: FEEE     [110]    	cp	0b11101110		; ← + SHIFT
C137: CA45B7   [120|120]	jp	z,movcurhor
C13A: 0608     [127]    	ld	b,0x08		; +8 pixels (1 char)
C13C: FE7F     [134]    	cp	0b01111111		; →
C13E: CA45B7   [144|144]	jp	z,movcurhor
C141: FEBF     [151]    	cp	0b10111111		; ↓
C143: CA51B7   [161|161]	jp	z,movcurver
C146: 06F8     [168]    	ld	b,0xf8		; -8 pixels (1 char)
C148: FEDF     [175]    	cp	0b11011111		; ↑
C14A: CA51B7   [185|185]	jp	z,movcurver
C14D: FEEF     [192]    	cp	0b11101111		; ←
C14F: CA45B7   [202|202]	jp	z,movcurhor
C152:                   nmak8:
C152: C9       [10]     	ret				; if no key found return without killing buffer
                        
C153:                   readrectkeys:
C153: 3AE7FB   [13]     	ld	a,(NEWKEY+2)	; keyboard matrix: B A DEAD /? .> ,< `~ '"
C156: FEFF     [20]     	cp	0xff			; pressed key on this row?
C158: 2805     [27|32]  	jr	z,nrek2		; if not, jump to next
C15A: FE7F     [34]     	cp	0b01111111		; b
C15C: CAECB7   [44|44]  	jp	z,changerect
C15F:                   nrek2:
C15F: 3AE8FB   [13]     	ld	a,(NEWKEY+3)	; keyboard matrix: J I H G F E D C
C162: FEFF     [20]     	cp	0xff			; pressed key on this row?
C164: 2805     [27|32]  	jr	z,nrek3		; if not, jump to next
C166: FEFE     [34]     	cp	0b11111110		; c
C168: CAB6B8   [44|44]  	jp	z,cancelrect
C16B:                   nrek3:
                        ; 	ld	a,(NEWKEY+5)	; keyboard matrix: Z Y X W V U T S
                        ; 	cp	0xff			; pressed key on this row?
                        ; 	jr	z,nrek5		; if not, jump to next
                        ; nrek5:
C16B: 3AECFB   [13]     	ld	a,(NEWKEY+7)	; keyboard matrix: RET SELECT BS STOP TAB ESC F5 F4
C16E: FEFF     [20]     	cp	0xff			; pressed key on this row?
C170: 280F     [27|32]  	jr	z,nrek7		; if not, jump to next
C172: FE7F     [34]     	cp	0b01111111		; ENTER
C174: CA55B8   [44|44]  	jp	z,activaterect
C177: FEDF     [51]     	cp	0b11011111		; BS
C179: CAB6B8   [61|61]  	jp	z,cancelrect
C17C: FEFB     [68]     	cp	0b11111011		; ESC
C17E: CAB6B8   [78|78]  	jp	z,cancelrect
C181:                   nrek7:
C181: C9       [10]     	ret				; if no key found return without killing buffer
                        
C182:                   readpastbxkeys:
C182: 3AE8FB   [13]     	ld	a,(NEWKEY+3)	; keyboard matrix: J I H G F E D C
C185: FEFF     [20]     	cp	0xff			; pressed key on this row?
C187: 280A     [27|32]  	jr	z,npak3		; if not, jump to next
C189: FEF7     [34]     	cp	0b11110111		; f
C18B: CA83B5   [44|44]  	jp	z,swapbuffers
C18E: FEFE     [51]     	cp	0b11111110		; c
C190: CADDB9   [61|61]  	jp	z,cancelpaste
C193:                   npak3:
C193: 3AEAFB   [13]     	ld	a,(NEWKEY+5)	; keyboard matrix: Z Y X W V U T S
C196: FEFF     [20]     	cp	0xff			; pressed key on this row?
C198: 280F     [27|32]  	jr	z,npak5		; if not, jump to next
C19A: FEBF     [34]     	cp	0b10111111		; y
C19C: CAC4C2   [44|44]  	jp	z,setundo
C19F: FEF7     [51]     	cp	0b11110111		; v
C1A1: CADDB9   [61|61]  	jp	z,cancelpaste
C1A4: FEFB     [68]     	cp	0b11111011		; u
C1A6: CA76B5   [78|78]  	jp	z,undolast
C1A9:                   npak5:
C1A9: 3AECFB   [13]     	ld	a,(NEWKEY+7)	; keyboard matrix: RET SELECT BS STOP TAB ESC F5 F4
C1AC: FEFF     [20]     	cp	0xff			; pressed key on this row?
C1AE: 280F     [27|32]  	jr	z,npak7		; if not, jump to next
C1B0: FE7F     [34]     	cp	0b01111111		; ENTER
C1B2: CAB2B9   [44|44]  	jp	z,pastethebox
C1B5: FEDF     [51]     	cp	0b11011111		; BS
C1B7: CAC2B9   [61|61]  	jp	z,erasewithbox
C1BA: FEFB     [68]     	cp	0b11111011		; ESC
C1BC: CADDB9   [78|78]  	jp	z,cancelpaste
C1BF:                   npak7:
C1BF: C9       [10]     	ret				; if no key found return without killing buffer
                        
C1C0:                   readchmapkeys:
C1C0: 3AE7FB   [13]     	ld	a,(NEWKEY+2)	; keyboard matrix: B A DEAD /? .> ,< `~ '"
C1C3: FEFF     [20]     	cp	0xff			; pressed key on this row?
C1C5: 2805     [27|32]  	jr	z,ncmk2		; if not, jump to next
C1C7: FEEF     [34]     	cp	0b11101111		; /
C1C9: CC8EB2   [44|51]  	call	z,cancelcharmap
C1CC:                   ncmk2:
C1CC: 3AECFB   [13]     	ld	a,(NEWKEY+7)	; keyboard matrix: RET SELECT BS STOP TAB ESC F5 F4
C1CF: FEFF     [20]     	cp	0xff			; pressed key on this row?
C1D1: 280F     [27|32]  	jr	z,ncmk7		; if not, jump to next
C1D3: FE7F     [34]     	cp	0b01111111		; ENTER
C1D5: CC81B2   [44|51]  	call	z,getfrommap
C1D8: FEDF     [51]     	cp	0b11011111		; BS
C1DA: CA7CB2   [61|61]  	jp	z,geterasechar
C1DD: FEFB     [68]     	cp	0b11111011		; ESC
C1DF: CC8EB2   [78|85]  	call	z,cancelcharmap
C1E2:                   ncmk7:
C1E2: C9       [10]     	ret				; if no key found return without killing buffer
                        
C1E3:                   readedchkeys:
C1E3: 3AEBFB   [13]     	ld	a,(NEWKEY+6)	; keyboard matrix: F3 F2 F1 CODE CAPS GRAPH CTRL SHIFT
C1E6: 57       [17]     	ld	d,a			; store in d
                        
C1E7: 3AE5FB   [30]     	ld	a,(NEWKEY+0)	; keyboard matrix: 7& 6^ 5% 4$ 3# 2@ 1! 0)
C1EA: FEFF     [37]     	cp	0xff			; pressed key on this row?
C1EC: 281C     [44|49]  	jr	z,neck0		; if not, jump to next
C1EE: 0601     [51]     	ld	b,0x01
C1F0: FEEF     [58]     	cp	0b11101111		; 4
C1F2: CA93BE   [68|68]  	jp	z,edtbackcolor
C1F5: 06FF     [75]     	ld	b,0xff
C1F7: FEF7     [82]     	cp	0b11110111		; 3
C1F9: CA93BE   [92|92]  	jp	z,edtbackcolor
C1FC: 0601     [99]     	ld	b,0x01
C1FE: FEFB     [106]    	cp	0b11111011		; 2
C200: CA6DBE   [116|116]	jp	z,edtforecolor
C203: 06FF     [123]    	ld	b,0xff
C205: FEFD     [130]    	cp	0b11111101		; 1
C207: CA6DBE   [140|140]	jp	z,edtforecolor
C20A:                   neck0:
C20A: 3AE7FB   [13]     	ld	a,(NEWKEY+2)	; keyboard matrix: B A DEAD /? .> ,< `~ '"
C20D: FEFF     [20]     	cp	0xff			; pressed key on this row?
C20F: 280A     [27|32]  	jr	z,neck2		; if not, jump to next
C211: FEBF     [34]     	cp	0b10111111		; a
C213: CA18BF   [44|44]  	jp	z,edtscrlft
C216: FEF7     [51]     	cp	0b11110111		; .
C218: CA85BC   [61|61]  	jp	z,acceptedit
C21B:                   neck2:
C21B: 3AE8FB   [13]     	ld	a,(NEWKEY+3)	; keyboard matrix: J I H G F E D C
C21E: FEFF     [20]     	cp	0xff			; pressed key on this row?
C220: 281E     [27|32]  	jr	z,neck3		; if not, jump to next
C222: FE7F     [34]     	cp	0b01111111		; j
C224: CAE3BE   [44|44]  	jp	z,edtcheckb
C227: FEDF     [51]     	cp	0b11011111		; h
C229: CAD0BE   [61|61]  	jp	z,edtinvert
C22C: FEF7     [68]     	cp	0b11110111		; f
C22E: CAD5BF   [78|78]  	jp	z,edtrotlft
C231: FEFB     [85]     	cp	0b11111011		; e
C233: CA90BF   [95|95]  	jp	z,edtfliphrz
C236: FEFD     [102]    	cp	0b11111101		; d
C238: CA2CBF   [112|112]	jp	z,edtscrlrgt
C23B: FEFE     [119]    	cp	0b11111110		; c
C23D: CA16BE   [129|129]	jp	z,edtcopy
C240:                   neck3:
C240: 3AE9FB   [13]     	ld	a,(NEWKEY+4)	; keyboard matrix: R Q P O N M L K
C243: FEFF     [20]     	cp	0xff			; pressed key on this row?
C245: 2814     [27|32]  	jr	z,neck4		; if not, jump to next
C247: FE7F     [34]     	cp	0b01111111		; r
C249: CAAFBF   [44|44]  	jp	z,edtrotrgt
C24C: FEBF     [51]     	cp	0b10111111		; q
C24E: CA75BF   [61|61]  	jp	z,edtflipvrt
C251: FEFD     [68]     	cp	0b11111101		; l
C253: CA09BF   [78|78]  	jp	z,edtclear
C256: FEFE     [85]     	cp	0b11111110		; k
C258: CAFABE   [95|95]  	jp	z,edtfill
C25B:                   neck4:
C25B: 3AEAFB   [13]     	ld	a,(NEWKEY+5)	; keyboard matrix: Z Y X W V U T S
C25E: FEFF     [20]     	cp	0xff			; pressed key on this row?
C260: 2846     [27|32]  	jr	z,neck5		; if not, jump to next
C262: A2       [31]     	and	d
C263: 06F1     [38]     	ld	b,0xf1		; -16 chracters
C265: FE7E     [45]     	cp	0b01111110		; z + SHIFT
C267: CAB2BD   [55|55]  	jp	z,edtrollchar
C26A: 06FF     [62]     	ld	b,0xff		; -1 character
C26C: FE7F     [69]     	cp	0b01111111		; z
C26E: CAB2BD   [79|79]  	jp	z,edtrollchar
C271: FEBF     [86]     	cp	0b10111111		; y
C273: CACABD   [96|96]  	jp	z,edtsetundo
C276: 060F     [103]    	ld	b,0x0f		; +16 chracters
C278: FEDE     [110]    	cp	0b11011110		; x + SHIFT
C27A: CAB2BD   [120|120]	jp	z,edtrollchar
C27D: 0601     [127]    	ld	b,0x01		; +1 character
C27F: FEDF     [134]    	cp	0b11011111		; x
C281: CAB2BD   [144|144]	jp	z,edtrollchar
C284: FEEF     [151]    	cp	0b11101111		; w
C286: CA40BF   [161|161]	jp	z,edtscrup
C289: 0600     [168]    	ld	b,0x00
C28B: FEF7     [175]    	cp	0b11110111		; v
C28D: CA37BE   [185|185]	jp	z,edtpaste
C290: 0601     [192]    	ld	b,0x01
C292: FEF6     [199]    	cp	0b11110110		; v + SHIFT
C294: CA37BE   [209|209]	jp	z,edtpaste
C297: 0602     [216]    	ld	b,0x02
C299: FEF5     [223]    	cp	0b11110101		; v + CTRL
C29B: CA37BE   [233|233]	jp	z,edtpaste
C29E: FEFB     [240]    	cp	0b11111011		; u
C2A0: CAECBD   [250|250]	jp	z,edtundo
C2A3: FEFE     [257]    	cp	0b11111110		; s
C2A5: CA55BF   [267|267]	jp	z,edtscrdwn
C2A8:                   neck5:
C2A8: 3AECFB   [13]     	ld	a,(NEWKEY+7)	; keyboard matrix: RET SELECT BS STOP TAB ESC F5 F4
C2AB: FEFF     [20]     	cp	0xff			; pressed key on this row?
C2AD: 2814     [27|32]  	jr	z,neck7		; if not, jump to next
C2AF: FE7F     [34]     	cp	0b01111111		; ENTER
C2B1: CAAEBC   [44|44]  	jp	z,enterredit
C2B4: FEDF     [51]     	cp	0b11011111		; BS
C2B6: CA02BC   [61|61]  	jp	z,savewrkchrs
C2B9: FEF7     [68]     	cp	0b11110111		; TAB
C2BB: CAE1BB   [78|78]  	jp	z,swapwrkchrs
C2BE: FEFB     [85]     	cp	0b11111011		; ESC
C2C0: CA67BC   [95|95]  	jp	z,canceledit
C2C3:                   neck7:
C2C3: C9       [10]     	ret				; if no key found return without killing buffer
                        #include "masciiSR.asm"		; support routines
                        ; ------------------SUPPORT ROUTINES
                        
C2C4:                   setundo:				; copy screen to undo buffer
C2C4: 210018   [10]     	ld	hl,0x1800		; screen address
C2C7: 11000C   [20]     	ld	de,VRBUF2		; undo buffer
C2CA: 010003   [30]     	ld	bc,0x300		; screen size
C2CD: CD0BC3   [47]     	call	streamvv		; copy screen for undo
C2D0: CD5601   [64]     	call	kilbuf
C2D3: C9       [74]     	ret
                        
C2D4:                   copyscrtobuf2:			; save screen in buffer 2
C2D4: 210018   [10]     	ld	hl,0x1800		; initial VRAM pos
C2D7: 1148D4   [20]     	ld	de,buffer2		; buffer to use
C2DA: 010003   [30]     	ld	bc,0x0300		; the whole screen
C2DD: CD5900   [47]     	call	ldirmv		; put VRAM on RAM
C2E0: C9       [57]     	ret
                        
C2E1:                   copytovram:				; copy amount to VRAm and increase HL and DE
                        					; input: C=amount,DE=RAM,HL=VRAM
                        					; output: HL+C,DE+C
C2E1: C5       [11]     	push	bc			; save B
C2E2: 41       [15]     	ld	b,c			; copy amount to B
C2E3: 1A       [ 7]     lpctv:ld	a,(de)		; get byte
C2E4: CD4D00   [24]     	call	wrtvrm		; write to VRAM
C2E7: 23       [30]     	inc	hl			; next VRAM address
C2E8: 13       [36]     	inc	de			; next RAM address
C2E9: 10F8     [44|49]  	djnz	lpctv			; loop
C2EB: C1       [54]     	pop	bc			; restore B
C2EC: C9       [64]     	ret
                        
C2ED:                   swapvv:				; swap between VRAM areas
                        					; input: HL=area 1,DE=area 2,BC=length
C2ED: CD4A00   [17]     	call	rdvrm			; read char from orig
C2F0: F5       [28]     	push	af
C2F1: EB       [32]     	ex	de,hl			; exchange orig x dest
C2F2: CD4A00   [49]     	call	rdvrm			; read char from orig
C2F5: 08       [53]     	ex	af,af'
C2F6: F1       [63]     	pop	af
C2F7: CD4D00   [80]     	call	wrtvrm		; write char to dest
C2FA: 08       [84]     	ex	af,af'
C2FB: EB       [88]     	ex	de,hl			; exchange back
C2FC: CD4D00   [105]    	call	wrtvrm		; write char to dest
C2FF: 13       [111]    	inc	de			; increment destination
C300: 23       [117]    	inc	hl			; increment origin
C301: 0B       [123]    	dec	bc			; decrement length counter
C302: 78       [127]    	ld	a,b			; put high byte in A
C303: B1       [131]    	or	c			; compare with C
C304: C2EDC2   [141|141]	jp	nz,swapvv		; if both not 0, loop
C307: CD5601   [158]    	call	kilbuf		; clear keyboard buffer
C30A: C9       [168]    	ret
                        
C30B:                   streamvv:				; stream from VRAM to VRAM
                        					; input: HL=origin,DE=dest,BC=length
C30B: F5       [11]     	push	af			; save A
C30C: CD4A00   [17]     lstv1:call	rdvrm			; read char from orig
C30F: EB       [21]     	ex	de,hl			; exchange orig x dest
C310: CD4D00   [38]     	call	wrtvrm		; write char to dest
C313: EB       [42]     	ex	de,hl			; exchange back
C314: 13       [48]     	inc	de			; increment destination
C315: 23       [54]     	inc	hl			; increment origin
C316: 0B       [60]     	dec	bc			; decrement length counter
C317: 78       [64]     	ld	a,b			; put high byte in A
C318: B1       [68]     	or	c			; compare with C
C319: C20CC3   [78|78]  	jp	nz,lstv1		; if both not 0, loop
C31C: F1       [88]     	pop	af			; restore A
C31D: C9       [98]     	ret
                        
C31E:                   createcharmap:			; create a 16x16 character map
                        					; input: HL=top left corner
C31E: 111000   [10]     	ld	de,0x10		; get VRAM advance amount for next row
C321: 0610     [17]     	ld	b,0x10		; get columns amount
C323: 48       [21]     	ld	c,b			; put also in rows amount
C324: 3E00     [28]     	ld	a,0			; define character as 0
C326: CD4D00   [17]     lsec1:call	wrtvrm		; write character on the screen
C329: 3C       [21]     	inc	a			; go to the next character
C32A: 23       [27]     	inc	hl			; go to the next screen column
C32B: 10F9     [35|40]  	djnz	lsec1			; dec columns counter, if not 0, loop
C32D: 19       [46]     	add	hl,de			; advance to the start of next row
C32E: 0610     [53]     	ld	b,0x10		; reset columns counter
C330: 0D       [57]     	dec	c			; decrement lines counter
C331: 20F3     [64|69]  	jr	nz,lsec1		; if not 0, loop
C333: C9       [74]     	ret
                        
C334:                   drawlogosmall:			; draw a small MASCIIDRAWX logo
                        					; input: HL=screen pos
C334: 3E80     [ 7]     	ld	a,0x80		; get first character
C336: 0608     [14]     	ld	b,0x08		; get length
C338: CD4D00   [17]     ldls1:call	wrtvrm		; write char on screen	
C33B: 3C       [21]     	inc	a			; next char
C33C: 23       [27]     	inc	hl			; next screen pos
C33D: 10F9     [35|40]  	djnz	ldls1			; do until finished
C33F: C9       [45]     	ret
                        
C340:                   boxrv:				; copy rectangle from RAM to VRAM
                        					; input: HL=buffer,RECTT variable +1=VRAM pos,+3=height,+4=width
C340: ED5B68C4 [20]     	ld	de,(rectt+1)	; get initial VRAM pos 
C344: 3A6AC4   [33]     	ld	a,(rectt+3)		; get height
C347: 47       [37]     	ld	b,a			; put in B
C348: C5       [11]     lbxrv:push	bc			; save height
C349: 3A6BC4   [24]     	ld	a,(rectt+4)		; get width
C34C: 0600     [31]     	ld	b,0			; put in BC
C34E: 4F       [35]     	ld	c,a			;
C34F: C5       [46]     	push	bc			; save width
C350: E5       [57]     	push	hl			; save origin RAM
C351: D5       [68]     	push	de			; save destination VRAM
                        					; prevent pasting beyond screen area
C352: D5       [79]     	push	de			; save VRAM address
C353: EB       [83]     	ex	de,hl			; exchange with HL
C354: 09       [94]     	add	hl,bc			; add to width
C355: 2B       [100]    	dec	hl			; decrement 1 to adjust
C356: 7C       [104]    	ld	a,h			; get VRAM address high byte
C357: FE1B     [111]    	cp	0x1b			; compare to the end of screen
C359: EB       [115]    	ex	de,hl			; exchange back
C35A: D1       [125]    	pop	de			; restore VRAM address
C35B: 3003     [132|137]	jr	nc,sbxrv		; if higher, skip
                        
C35D: CD5C00   [149]    	call	ldirvm		; fill VRAM width
C360: E1       [10]     sbxrv:pop	hl			; get VRAM
C361: 112000   [20]     	ld	de,32			; get 32
C364: 19       [31]     	add	hl,de			; add 32 to VRAM (next line)
C365: EB       [35]     	ex	de,hl			; DE=VRAM >< HL=32
C366: E1       [45]     	pop	hl			; get RAM
C367: C1       [55]     	pop	bc			; get width
C368: D5       [66]     	push	de			; save VRAM
C369: 50       [70]     	ld	d,b			; DE = width
C36A: 59       [74]     	ld	e,c			;
C36B: 19       [85]     	add	hl,de			; add width to RAM
C36C: D1       [95]     	pop	de			; get VRAM
C36D: C1       [105]    	pop	bc			; get height
C36E: 10D8     [113|118]	djnz	lbxrv			; decrease and loop until 0
C370: C9       [123]    	ret
                        
C371:                   boxvrb1:				; copy rectangle from VRAM to RAM
                        					; send to BOXVRB2 to preserv buffer 1 content dimensions
                        					; input: DE=buffer,RECTT variable +1=VRAM pos,+3=height,+4=width
C371: 2A6AC4   [16]     	ld	hl,(rectt+3)	; get box dimensions
C374: 2246D1   [32]     	ld	(buffcont1),hl	; save in buffer 1 content dimensions
C377:                   boxvrb2:				; entry point for buffer 2
C377: 2A68C4   [16]     	ld	hl,(rectt+1)	; get initial VRAM pos 
C37A: 3A6AC4   [29]     	ld	a,(rectt+3)		; get height
C37D: 47       [33]     	ld	b,a			; put in B
C37E: C5       [11]     lbxvr:push	bc			; save height
C37F: 3A6BC4   [24]     	ld	a,(rectt+4)		; get width
C382: 0600     [31]     	ld	b,0			; put in BC
C384: 4F       [35]     	ld	c,a			;
C385: C5       [46]     	push	bc			; save width
C386: D5       [57]     	push	de			; save RAM
C387: E5       [68]     	push	hl			; save VRAM
C388: CD5900   [85]     	call	ldirmv		; fill VRAM width
C38B: E1       [95]     	pop	hl			; get VRAM
C38C: 112000   [105]    	ld	de,0x20		; increment for advancing screen line
C38F: 19       [116]    	add	hl,de			; add 32 to VRAM (lext line)
C390: D1       [126]    	pop	de			; get RAM
C391: EB       [130]    	ex	de,hl			; DE=VRAM >< HL=RAM
C392: C1       [140]    	pop	bc			; get width
C393: D5       [151]    	push	de			; save VRAM
C394: 50       [155]    	ld	d,b			; DE = width
C395: 59       [159]    	ld	e,c			; 
C396: 19       [170]    	add	hl,de			; add width to RAM
C397: D1       [180]    	pop	de			; get VRAM
C398: EB       [184]    	ex	de,hl			; DE=RAM >< HL=VRAM
C399: C1       [194]    	pop	bc			; get height
C39A: 10E2     [202|207]	djnz	lbxvr			; decrease and loop until 0
C39C: C9       [212]    	ret
                        
C39D:                   hidecur:				; hide the cursor
C39D: 3ED1     [ 7]     	ld	a,209			; get 209 for position
C39F: 2A72C4   [23]     	ld	hl,(spcursor+6)	; get cursor sprite y VRAM pos
C3A2: CD4D00   [40]     	call	wrtvrm		; assign
C3A5: C9       [50]     	ret
                        
C3A6:                   hidecharcur:			; hide the character cursors
C3A6: 3ED1     [ 7]     	ld	a,209			; get 209 for position
C3A8: 2A1CC5   [23]     	ld	hl,(spcharac+6)	; get character sprite y VRAM pos
C3AB: CD4D00   [40]     	call	wrtvrm		; assign
C3AE: 2A2DC5   [56]     	ld	hl,(spbckgrd+6)	; get background sprite y VRAM pos
C3B1: CD4D00   [73]     	call	wrtvrm		; assign
C3B4: C9       [83]     	ret
                        
C3B5:                   hideboxcur:				; hide the rectangle cursors
C3B5: 3ED1     [ 7]     	ld	a,209			; get 209 for y pos
C3B7: 2A83C4   [23]     	ld	hl,(spboxfil+6)	; get box fil sprite y pos
C3BA: CD4D00   [40]     	call	wrtvrm		; assign
C3BD: 2A94C4   [56]     	ld	hl,(spboxhol+6)	; get box hollow sprite y pos
C3C0: CD4D00   [73]     	call	wrtvrm		; assign
C3C3: 2AA5C4   [89]     	ld	hl,(spboxlin+6)	; get box line sprite y pos
C3C6: CD4D00   [106]    	call	wrtvrm		; assign
C3C9: 2AB6C4   [122]    	ld	hl,(spboxadd+6)	; get box line add sprite y pos
C3CC: CD4D00   [139]    	call	wrtvrm		; assign
C3CF: C9       [149]    	ret
                        
C3D0:                   chbordcolor:			; change the border color
                        					; input: A=color
C3D0: 32EBF3   [13]     	ld (BDRCLR),a		; set border color variable (for outside use)
C3D3: F5       [24]     	push	af			; save border color
C3D4: 3A0700   [37]     	ld	a,(7)			; A = Main-ROM slot
C3D7: 4F       [41]     	ld	c,a			; put in C
C3D8: 0C       [45]     	inc	c			; C = CPU port connected to the VDP writing port #1
                         
C3D9: F3       [49]     	di				; Interrupts must be disabled here
C3DA: F1       [59]     	pop	af			; restore border color
C3DB: ED79     [71]     	out	(c),a			; Write the color
C3DD: 0687     [78]     	ld 	b,0x07+0x80		; pick border color register 
C3DF: ED41     [90]     	out	(c),b			; Write register 7 (with the bit 7 (0x80) always set)
C3E1: FB       [94]     	ei				; Interrupts can be enabled here
C3E2: C9       [104]    	ret
                        
C3E3:                   add8to16:				; add 8 bits to 16 bits
                        					; input: DE=16bits,A=8bits
                        					; output: DE+A
C3E3: 83       [ 4]     	add	a,e			; add A to E
C3E4: 5F       [ 8]     	ld	e,a			; put A in E
C3E5: 8A       [12]     	adc	a,d			; add A to D with carry
C3E6: 93       [16]     	sub	e			; subtract E from A
C3E7: 57       [20]     	ld	d,a			; put A in D
C3E8: C9       [30]     	ret
                        
C3E9:                   toggleflags:			; toggle bits on the flag byte
                        					; input B as bitmask (1 toggle, 0 stay)
C3E9: 3A08B0   [13]     	ld	a,(flags)		; read flags byte
C3EC: A8       [17]     	xor	b 			; toggle bits
C3ED: 3208B0   [30]     	ld	(flags),a		; save flags byte
C3F0: CD5601   [47]     	call	kilbuf		; clear keyboard buffer
C3F3: C9       [57]     	ret
                        
C3F4:                   checkcurspos:			; chech current cursor position (CURAT)
                        					; output: C if beyond VRAM screen area
                        					; alter: A
C3F4: 2A2DC4   [16]     	ld	hl,(curat)		; get x,y (read bytes pos inverted)
C3F7: CD10C4   [33]     	call	vrampos		; get the VRAM position
C3FA: 3E1A     [40]     	ld	a,0x1a		; get end of screen VRAM high byte
C3FC: BC       [44]     	cp	h			; compare with character pos high byte
C3FD: C9       [54]     	ret
                        
C3FE:                   wrtvrms:				; Write to VRAM safe
                        					; do not write under &h1800 or over &h1aff
                        					; input: H=RAM position high byte,A=character
C3FE: F5       [11]     	push	af			; save character
C3FF: 3E17     [18]     	ld	a,0x17		; high byte of address before the screen area
C401: BC       [22]     	cp	h			; compare to current high byte
C402: 300A     [29|34]  	jr	nc,swtvr		; if equal or lower, skip writing
C404: 3E1A     [36]     	ld	a,0x1a		; get end of screen VRAM high byte
C406: BC       [40]     	cp	h			; compare with character pos high byte
C407: 3805     [47|52]  	jr	c,swtvr		; if higher, skip writing
C409: F1       [57]     	pop	af			; restore character
C40A: CD4D00   [74]     	call	wrtvrm		; write to VRAM
C40D: C9       [84]     	ret
C40E: F1       [10]     swtvr:pop	af			; restore character
C40F: C9       [20]     	ret
                        
C410:                   vrampos:				; calc character screen position
                        					; input: h=x,l=y (191,255)
                        					; output: hl = VRAM position (&h1800-&h1aff)
                        					; alter: a, hl
C410: E5       [11]     	push	hl			; save HL with x,y information
C411: 7D       [15]     	ld	a,l			; get y pos
C412: C604     [22]     	add	4			; offset cursor
C414: E6F8     [29]     	and	0b11111000		; step by 8 increments
C416: 2600     [36]     	ld	h,0			; pos y to L
C418: 6F       [40]     	ld	l,a			;
C419: 29       [51]     	add	hl,hl			; hl * 2
C41A: 29       [62]     	add	hl,hl			; hl * 4
                        
C41B: EB       [66]     	ex	de,hl			; preserve HL excanging with DE
C41C: E1       [76]     	pop	hl			; restore previous HL with x,y information
C41D: 7C       [80]     	ld	a,h			; get x pos
C41E: EB       [84]     	ex	de,hl			; restore original HL and DE values
                        
C41F: C604     [91]     	add	4			; offset cursor
C421: E6F8     [98]     	and	0b11111000		; step by 8 increments
C423: 0F       [102]    	rrca				; divide by 2
C424: 0F       [106]    	rrca				; divide by 4
C425: 0F       [110]    	rrca				; divide by 8
                        
C426: 85       [114]    	add	a,l 			; add l to x pos
C427: 6F       [118]    	ld	l,a			; put in l
C428: 3E18     [125]    	ld	a,0x18		; put &h18 in a
C42A: 84       [129]    	add	a,h			; add h to a
C42B: 67       [133]    	ld	h,a			; put in h
C42C: C9       [143]    	ret
                        #include "masciiDT.asm"		; data
                        ; ------------------DATA
                        
                        ; system BIOS calls
0020:                   dcompr:	equ 0x0020	; compare HL with DE
004A:                   rdvrm:	equ 0x004a	; read from VRAM
004D:                   wrtvrm:	equ 0x004d	; write to VRAM
0056:                   filvrm:	equ 0x0056	; fill VRAM with value
0059:                   ldirmv:	equ 0x0059	; block VRAM to RAM
005C:                   ldirvm:	equ 0x005c	; block RAM to VRAM
005F:                   chgmod:	equ 0x005f	; change screen modes
0062:                   chgclr:	equ 0x0062	; change screen color
006F:                   init32:	equ 0x006f	; initialize screen 1
0084:                   calpat:	equ 0x0084	; Sprite pattern table address
0087:                   calatr:	equ 0x0087	; Sprite attribute table address
009C:                   chsns:	equ 0x009c	; check keyboard buffer
009F:                   chget:	equ 0x009f	; get key press
00B1:                   inlin: 	equ 0x00b1	; enter character sequence
00B7:                   breakx:	equ 0x00b7	; test for CRTL+STOP
00C3:                   cls:		equ 0x00c3	; clear the screen
00C0:                   beep:		equ 0x00c0	; generates a beep
00C6:                   posit:	equ 0x00c6	; position the cursor
00CC:                   erafnk:	equ 0x00cc	; toggle function keys display
00D8:                   gttrig: 	equ 0x00d8	; get trigger
0141:                   snsmat:	equ 0x0141	; read keyboard matrix (not used)
0156:                   kilbuf:	equ 0x0156	; clear keyboard buffer
                        
                        ; system variables
F3E9:                   FORCLR:	equ 0xf3e9	; foreground color
F3EA:                   BAKCLR:	equ 0xf3ea	; background color
F3EB:                   BDRCLR:	equ 0xf3eb	; border color
F3AF:                   LINL32:	equ 0xf3af	; screen 1 columns
F3E8:                   TRGFLG:	equ 0xf3e8	; trigger flags
FBE5:                   NEWKEY:	equ 0xfbe5	; read keyboard matrix
FCA9:                   CSRSW:	equ 0xfca9	; text cursor show
                        
                        ; user constants
                        ; small VRAM buffers 0x400 length
0800:                   VRBUF1:	equ 0x0800	; unused
0C00:                   VRBUF2:	equ 0x0c00	; undo
1000:                   VRBUF3:	equ 0x1000	; swap buffer
1400:                   VRBUF4:	equ 0x1400	; temporary storage for names
                        ; big VRAM buffers 0x800 length
2800:                   VRBUF5:	equ 0x2800	; temporary storage for patterns
3000:                   VRBUF6:	equ 0x3000	; temporary storage for colors
                        
                        ; user data
C42D: 6080D100          curat:	defb 96,128,209,0,0,0			; cursor: y,x,y1,x1,last y,last x
C431: 0000              
C433: 41002001          		defb 0x41,0x00,0x20,0x01		; cursor: char,char backup,erase char,color
C437: 0000              edtch:	defb 0x00,0x00				; sel edit char,grid char
C439: 00000000          edthelpch:	defs 0x08,0x00				; edit helper character
C43D: 00000000          
C441: 00000000          edtcopych:	defs 0x08,0x00				; edit copy character
C445: 00000000          
C449: 00000000          edtcopycl:	defs 0x08,0x00				; edit copy color
C44D: 00000000          
C451: 00000000          edtundoch:	defs 0x08,0x00				; edit undo character
C455: 00000000          
C459: 00000000          edtundocl:	defs 0x08,0x00				; edit undo ccolor
C45D: 00000000          
C461: 0F0E0EFE          scrat:	defb 0xf,0xe,0xe,0xfe,0xfe,0		; def colors: fore,back,bord,font(FG&BG),not used(FG&BG),bord bkp
C465: FE00              
C467: 00                rectt:	defb 0x00					; rectangle: type 0=hollow,1=filled,2=line,3=line add,4=copy
C468: 00000000          		defb 0x00,0x00,0x00,0x00		; rectangle: VRAM start(2b),height,width
                        
                        		; sprites:
C46C:                   spfrstal:	; y,x,number,color,pat VRAM pos(2b),atr VRAM pos(2b),quantity,pattern(8b)
C46C: 60800001          spcursor:	defb 96,128,0x00,1,0x00,0x00,0x00,0x00,1		; cursor sprite
C470: 00000000          
C474: 01                
C475: 81000000          		defb 0x81,0x00,0x00,0x00,0x00,0x00,0x00,0x81
C479: 00000081          
C47D: D1000001          spboxfil:	defb 209,0,0x00,1,0x00,0x00,0x00,0x00,2		; filled box
C481: 00000000          
C485: 02                
C486: FEFEFEFE          		defb 0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0x00
C48A: FEFEFE00          
C48E: D1000001          spboxhol:	defb 209,0,0x00,1,0x00,0x00,0x00,0x00,3		; hollow box
C492: 00000000          
C496: 03                
C497: AA008200          		defb 0xaa,0x00,0x82,0x00,0x82,0x00,0xaa,0x00
C49B: 8200AA00          
C49F: D1000001          spboxlin:	defb 209,0,0x00,1,0x00,0x00,0x00,0x00,4		; line box
C4A3: 00000000          
C4A7: 04                
C4A8: FE828282          		defb 0xfe,0x82,0x82,0x82,0x82,0x82,0xfe,0x00
C4AC: 8282FE00          
C4B0: D1000001          spboxadd:	defb 209,0,0x00,1,0x00,0x00,0x00,0x00,5		; add line box
C4B4: 00000000          
C4B8: 05                
C4B9: FE9292FE          		defb 0xfe,0x92,0x92,0xfe,0x92,0x92,0xfe,0x00
C4BD: 9292FE00          
C4C1: D1000001          spboxchr:	defb 209,0,0x00,1,0x00,0x00,0x00,0x00,6		; add line box
C4C5: 00000000          
C4C9: 06                
C4CA: FE00FE00          		defb 0xfe,0x00,0xfe,0x00,0xfe,0x00,0xfe,0x00
C4CE: FE00FE00          
C4D2: D1000001          spimcopy:	defb 209,0,0x00,1,0x00,0x00,0x00,0x00,7		; copy box
C4D6: 00000000          
C4DA: 07                
C4DB: F8F8FEFA          		defb 0xf8,0xf8,0xfe,0xfa,0xfa,0x22,0x3e,0x00
C4DF: FA223E00          
C4E3: D1000001          spimpast:	defb 209,0,0x00,1,0x00,0x00,0x00,0x00,8		; paste box
C4E7: 00000000          
C4EB: 08                
C4EC: F888BEBE          		defb 0xf8,0x88,0xbe,0xbe,0xfe,0x3e,0x3e,0x00
C4F0: FE3E3E00          
C4F4: D1000001          speditch:	defb 209,0,0x00,1,0x00,0x00,0x00,0x00,9		; edit char grid
C4F8: 00000000          
C4FC: 09                
C4FD: FF818181          		defb 0xff,0x81,0x81,0x81,0x81,0x81,0x81,0xff
C501: 818181FF          
C505:                   splastcu:
C505: D1000001          sptextent:	defb 209,0,0x00,1,0x00,0x00,0x00,0x00,10		; copy box
C509: 00000000          
C50D: 0A                
C50E: 00000000          		defb 0x00,0x00,0x00,0x00,0x00,0x00,0x81,0xff
C512: 000081FF          
C516: D100000F          spcharac:	defb 209,0,0x00,15,0x00,0x00,0x00,0x00,11		; character
C51A: 00000000          
C51E: 0B                
C51F: 00000000          		defb 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
C523: 00000000          
C527:                   splastal:
C527: D100000F          spbckgrd:	defb 209,0,0x00,15,0x00,0x00,0x00,0x00,12		; background
C52B: 00000000          
C52F: 0C                
C530: FFFFFFFF          		defb 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
C534: FFFFFFFF          
                        
                        		; edit screen work characters
                        		; patterns
C538: 007E7E7E          editonch:	defb 0x00,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x00	; grid on
C53C: 7E7E7E00          
C540: AA018001          editofch:	defb 0xaa,0x01,0x80,0x01,0x80,0x01,0x80,0x55	; grid off
C544: 80018055          
C548: 00000000          editbgch:	defb 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	; background
C54C: 00000000          
                        		; colors
C550: 00000000          editoncl:	defb 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	; grid on
C554: 00000000          
C558: 00000000          editofcl:	defb 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	; grid off
C55C: 00000000          
C560: 00000000          editbgcl:	defb 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	; background
C564: 00000000          
                        		; backup of chars being used for work.
C568: 00000000          editbkch:	defs 0x18,0x00						; patterns
C56C: 00...             
C580: 00000000          editbkcl:	defs 0x18,0x00						; colors
C584: 00...             
                        
                        		; working characters: on,off,background,xor,address of the other set	
C598: FDFEFF03          editwrk1:	defb 0xfd,0xfe,0xff,0x03				; set 1
C59C: 9EC5              		defw editwrk2
C59E: 00010201          editwrk2:	defb 0x00,0x01,0x02,0x01				; set 2
C5A2: 98C5              		defw editwrk1
C5A4: FDFEFF03          editwork:	defb 0xfd,0xfe,0xff,0x03				; set using
C5A8: 9EC5              		defw editwrk2
                        
                        		; text special chars: 0xff=new line,0x01-0x1f=space amount,0x00=end
                        		; general texts
C5AA: 636C6561          textclear:	defb "clear screen",0
C5AE: 72207363          
C5B2: 7265656E          
C5B6: 00                
C5B7: 72657365          textreset:	defb "reset screen",0
C5BB: 74207363          
C5BF: 7265656E          
C5C3: 00                
C5C4: 71756974          textquit:	defb "quit program",0
C5C8: 2070726F          
C5CC: 6772616D          
C5D0: 00                
C5D1: 41524520          textsure:	defb "ARE YOU SURE ?",0
C5D5: 594F5520          
C5D9: 53555245          
C5DD: 203F00            
                        
                        		; help text page index LUT
C5E0: F2C5B0C6          hlptxt:	defw texthelp1,texthelp2,texthelp3
C5E4: C8C7              
C5E6: D9C8ECC9          		defw texthelp4,texthelp5,texthelp6
C5EA: 23CB              
C5EC: 34CCABCC          		defw texthelp7,texthelp8,texthelp9
C5F0: 6CCD              
                        
                        		; help screen texts
C5F2: 683A4845          texthelp1:	defb "h:HELP",0xff,0xff
C5F6: 4C50FFFF          
C5FA: 20202061          		defb "   arw:NAVIGATE",0xff,0xff
C5FE: 72773A4E          
C602: 41564947          
C606: 415445FF          
C60A: FF                
C60B: 20202061          		defb "   any key:EXIT",0xff,0xff
C60F: 6E79206B          
C613: 65793A45          
C617: 584954FF          
C61B: FF                
C61C: 61727720          		defb "arw mouse:MOVE",0xff,0xff
C620: 6D6F7573          
C624: 653A4D4F          
C628: 5645FFFF          
C62C: 202B7368          		defb " +sht:MOVE * 4",0xff,0xff
C630: 743A4D4F          
C634: 5645202A          
C638: 2034FFFF          
C63C: 73706320          		defb "spc btn1:DRAW",0xff,0xff
C640: 62746E31          
C644: 3A445241          
C648: 57FFFF            
C64B: 62732062          		defb "bs btn2:ERASE",0xff,0xff
C64F: 746E323A          
C653: 45524153          
C657: 45FFFF            
C65A: 6D3A544F          		defb "m:TOGGLE MOUSE",0xff,0xff
C65E: 47474C45          
C662: 204D4F55          
C666: 5345FFFF          
C66A: 663A5357          		defb "f:SWAP SCREEN BUFFERS",0xff,0xff
C66E: 41502053          
C672: 43524545          
C676: 4E204255          
C67A: 46464552          
C67E: 53FFFF            
C681: 3720383A          		defb "7 8:CYCLE CURSOR COLOR",0xff,0xff
C685: 4359434C          
C689: 45204355          
C68D: 52534F52          
C691: 20434F4C          
C695: 4F52FFFF          
C699: 3920303A          		defb "9 0:CYCLE BORDER COLOR",0
C69D: 4359434C          
C6A1: 4520424F          
C6A5: 52444552          
C6A9: 20434F4C          
C6AD: 4F5200            
                        				
C6B0: 7A20783A          texthelp2:	defb "z x:CYCLE CHARACTERS",0xff,0xff
C6B4: 4359434C          
C6B8: 45204348          
C6BC: 41524143          
C6C0: 54455253          
C6C4: FFFF              
C6C6: 202B7368          		defb " +sht:CYCLE CHARACTERS * 16",0xff,0xff
C6CA: 743A4359          
C6CE: 434C4520          
C6D2: 43484152          
C6D6: 41435445          
C6DA: 5253202A          
C6DE: 203136FF          
C6E2: FF                
C6E3: 6E3A5049          		defb "n:PICK CHARACTER UNDER CURSOR",0xff,0xff
C6E7: 434B2043          
C6EB: 48415241          
C6EF: 43544552          
C6F3: 20554E44          
C6F7: 45522043          
C6FB: 5552534F          
C6FF: 52FFFF            
C702: 623A4359          		defb "b:CYCLE BOX MODES",0xff,0xff
C706: 434C4520          
C70A: 424F5820          
C70E: 4D4F4445          
C712: 53FFFF            
C715: 2046494C          		defb " FILLED WITH CURRENT CHARACTER",0xff,0xff
C719: 4C454420          
C71D: 57495448          
C721: 20435552          
C725: 52454E54          
C729: 20434841          
C72D: 52414354          
C731: 4552FFFF          
C735: 20484F4C          		defb " HOLLOW WITH CURRENT CHARACTER",0xff,0xff
C739: 4C4F5720          
C73D: 57495448          
C741: 20435552          
C745: 52454E54          
C749: 20434841          
C74D: 52414354          
C751: 4552FFFF          
C755: 20484F4C          		defb " HOLLOW LINES",0xff,0xff
C759: 4C4F5720          
C75D: 4C494E45          
C761: 53FFFF            
C764: 20484F4C          		defb " HOLLOW ADDING LINE",0xff,0xff
C768: 4C4F5720          
C76C: 41444449          
C770: 4E47204C          
C774: 494E45FF          
C778: FF                
C779: 2046494C          		defb " FILLED INCR CHARS FROM CURRENT",0xff,0xff
C77D: 4C454420          
C781: 494E4352          
C785: 20434841          
C789: 52532046          
C78D: 524F4D20          
C791: 43555252          
C795: 454E54FF          
C799: FF                
C79A: 20202065          		defb "   ent btn1 spc:DRAW",0xff,0xff
C79E: 6E742062          
C7A2: 746E3120          
C7A6: 7370633A          
C7AA: 44524157          
C7AE: FFFF              
C7B0: 20202065          		defb "   esc bs c btn2:CANCEL",0
C7B4: 73632062          
C7B8: 73206320          
C7BC: 62746E32          
C7C0: 3A43414E          
C7C4: 43454C00          
                        
C7C8: 633A434F          texthelp3:	defb "c:COPY AREA / PASTE",0xff,0xff
C7CC: 50592041          
C7D0: 52454120          
C7D4: 2F205041          
C7D8: 535445FF          
C7DC: FF                
C7DD: 763A5041          		defb "v:PASTE PREVIOUS COPY",0xff,0xff
C7E1: 53544520          
C7E5: 50524556          
C7E9: 494F5553          
C7ED: 20434F50          
C7F1: 59FFFF            
C7F4: 20202065          		defb "   ent btn1 spc:PASTE",0xff,0xff
C7F8: 6E742062          
C7FC: 746E3120          
C800: 7370633A          
C804: 50415354          
C808: 45FFFF            
C80B: 20202062          		defb "   bs btn2:ERASE AREA",0xff,0xff
C80F: 73206274          
C813: 6E323A45          
C817: 52415345          
C81B: 20415245          
C81F: 41FFFF            
C822: 20202063          		defb "   c v:CANCEL",0xff,0xff
C826: 20763A43          
C82A: 414E4345          
C82E: 4CFFFF            
C831: 2F3A5348          		defb "/:SHOW CHARACTER MAP PICKER",0xff,0xff
C835: 4F572043          
C839: 48415241          
C83D: 43544552          
C841: 204D4150          
C845: 20504943          
C849: 4B4552FF          
C84D: FF                
C84E: 20202065          		defb "   ent btn1 spc:PICK AND LEAVE",0xff,0xff
C852: 6E742062          
C856: 746E3120          
C85A: 7370633A          
C85E: 5049434B          
C862: 20414E44          
C866: 204C4541          
C86A: 5645FFFF          
C86E: 20202062          		defb "   bs btn2:PICK ERASE CHAR",0xff,0xff
C872: 73206274          
C876: 6E323A50          
C87A: 49434B20          
C87E: 45524153          
C882: 45204348          
C886: 4152FFFF          
C88A: 20202065          		defb "   esc /:LEAVE",0xff,0xff
C88E: 7363202F          
C892: 3A4C4541          
C896: 5645FFFF          
C89A: 3F3A4348          		defb "?:CHANGE CURRENT CHAR BY TYPING",0xff,0xff
C89E: 414E4745          
C8A2: 20435552          
C8A6: 52454E54          
C8AA: 20434841          
C8AE: 52204259          
C8B2: 20545950          
C8B6: 494E47FF          
C8BA: FF                
C8BB: 20202065          		defb "   esc:LEAVE WITHOUT CHANGING",0
C8BF: 73633A4C          
C8C3: 45415645          
C8C7: 20574954          
C8CB: 484F5554          
C8CF: 20434841          
C8D3: 4E47494E          
C8D7: 4700              
                        
C8D9: 743A454E          texthelp4:	defb "t:ENTER TEXT BY TYPING",0xff,0xff
C8DD: 54455220          
C8E1: 54455854          
C8E5: 20425920          
C8E9: 54595049          
C8ED: 4E47FFFF          
C8F1: 20202065          		defb "   ent ctl+stp:LEAVE",0xff,0xff
C8F5: 6E742063          
C8F9: 746C2B73          
C8FD: 74703A4C          
C901: 45415645          
C905: FFFF              
C907: 77206120          		defb "w a s d:SCROLL UP LEFT DOWN RGHT",0xff,0xff
C90B: 7320643A          
C90F: 5343524F          
C913: 4C4C2055          
C917: 50204C45          
C91B: 46542044          
C91F: 4F574E20          
C923: 52474854          
C927: FFFF              
C929: 7120653A          		defb "q e:FLIP VERTICAL HORIZONTAL",0xff,0xff
C92D: 464C4950          
C931: 20564552          
C935: 54494341          
C939: 4C20484F          
C93D: 52495A4F          
C941: 4E54414C          
C945: FFFF              
C947: 202B7368          		defb " +sht:ALSO FLIP PATTERNS",0xff,0xff
C94B: 743A414C          
C94F: 534F2046          
C953: 4C495020          
C957: 50415454          
C95B: 45524E53          
C95F: FFFF              
C961: 753A554E          		defb "u:UNDO / REDO (SOME FUNCTIONS)",0xff,0xff
C965: 444F202F          
C969: 20524544          
C96D: 4F202853          
C971: 4F4D4520          
C975: 46554E43          
C979: 54494F4E          
C97D: 5329FFFF          
C981: 793A5155          		defb "y:QUICK SAVE (LOSE UNDO)",0xff,0xff
C985: 49434B20          
C989: 53415645          
C98D: 20284C4F          
C991: 53452055          
C995: 4E444F29          
C999: FFFF              
C99B: 6573633A          		defb "esc:CLEAR SCREEN",0xff,0xff
C99F: 434C4541          
C9A3: 52205343          
C9A7: 5245454E          
C9AB: FFFF              
C9AD: 202B7366          		defb " +sft:CLEAR SCREEN W CURR CHAR",0xff,0xff
C9B1: 743A434C          
C9B5: 45415220          
C9B9: 53435245          
C9BD: 454E2057          
C9C1: 20435552          
C9C5: 52204348          
C9C9: 4152FFFF          
C9CD: 202B6374          		defb " +ctl:RESET SCREEN",0xff,0xff
C9D1: 6C3A5245          
C9D5: 53455420          
C9D9: 53435245          
C9DD: 454EFFFF          
C9E1: 712B6374          		defb "q+ctl:QUIT",0
C9E5: 6C3A5155          
C9E9: 495400            
                        
C9EC: 2E3A454E          texthelp5:	defb ".:ENTER EDIT CHARACTER MODE",0xff,0xff
C9F0: 54455220          
C9F4: 45444954          
C9F8: 20434841          
C9FC: 52414354          
CA00: 4552204D          
CA04: 4F4445FF          
CA08: FF                
CA09: 20202061          		defb "   arw mouse:MOVE",0xff,0xff
CA0D: 7277206D          
CA11: 6F757365          
CA15: 3A4D4F56          
CA19: 45FFFF            
CA1C: 20202020          		defb "    +sht:MOVE * 4",0xff,0xff
CA20: 2B736874          
CA24: 3A4D4F56          
CA28: 45202A20          
CA2C: 34FFFF            
CA2F: 20202073          		defb "   spc ent btn1:DRAW/CHOOSE CHAR",0xff,0xff
CA33: 70632065          
CA37: 6E742062          
CA3B: 746E313A          
CA3F: 44524157          
CA43: 2F43484F          
CA47: 4F534520          
CA4B: 43484152          
CA4F: FFFF              
CA51: 2020207A          		defb "   z x:CYCLE CHARACTERS",0xff,0xff
CA55: 20783A43          
CA59: 59434C45          
CA5D: 20434841          
CA61: 52414354          
CA65: 455253FF          
CA69: FF                
CA6A: 20202020          		defb "    +shtT:CYCLE CHARACTERS * 16",0xff,0xff
CA6E: 2B736874          
CA72: 543A4359          
CA76: 434C4520          
CA7A: 43484152          
CA7E: 41435445          
CA82: 5253202A          
CA86: 203136FF          
CA8A: FF                
CA8B: 20202031          		defb "   1 2:CYCLE FOREGROUND COLOR",0xff,0xff
CA8F: 20323A43          
CA93: 59434C45          
CA97: 20464F52          
CA9B: 4547524F          
CA9F: 554E4420          
CAA3: 434F4C4F          
CAA7: 52FFFF            
CAAA: 20202033          		defb "   3 4:CYCLE BACKGROUND COLOR",0xff,0xff
CAAE: 20343A43          
CAB2: 59434C45          
CAB6: 20424143          
CABA: 4B47524F          
CABE: 554E4420          
CAC2: 434F4C4F          
CAC6: 52FFFF            
CAC9: 20202077          		defb "   w a s d:SCROLL CHAR U D L R",0xff,0xff
CACD: 20612073          
CAD1: 20643A53          
CAD5: 43524F4C          
CAD9: 4C204348          
CADD: 41522055          
CAE1: 2044204C          
CAE5: 2052FFFF          
CAE9: 20202071          		defb "   q e:FLIP CHAR HORZ VERT",0xff,0xff
CAED: 20653A46          
CAF1: 4C495020          
CAF5: 43484152          
CAF9: 20484F52          
CAFD: 5A205645          
CB01: 5254FFFF          
CB05: 20202072          		defb "   r f:ROTATE CHAR LEFT RIGHT",0
CB09: 20663A52          
CB0D: 4F544154          
CB11: 45204348          
CB15: 4152204C          
CB19: 45465420          
CB1D: 52494748          
CB21: 5400              
                        
CB23: 45444954          texthelp6:	defb "EDIT CHARACTER MODE - CONT",0xff,0xff
CB27: 20434841          
CB2B: 52414354          
CB2F: 4552204D          
CB33: 4F444520          
CB37: 2D20434F          
CB3B: 4E54FFFF          
CB3F: 20202068          		defb "   h:INVERT CHAR",0xff,0xff
CB43: 3A494E56          
CB47: 45525420          
CB4B: 43484152          
CB4F: FFFF              
CB51: 2020206A          		defb "   j:CREATE CHECKERBOARD",0xff,0xff
CB55: 3A435245          
CB59: 41544520          
CB5D: 43484543          
CB61: 4B455242          
CB65: 4F415244          
CB69: FFFF              
CB6B: 2020206B          		defb "   k:CLEAR CHARACTER",0xff,0xff
CB6F: 3A434C45          
CB73: 41522043          
CB77: 48415241          
CB7B: 43544552          
CB7F: FFFF              
CB81: 2020206C          		defb "   l:FILL CHARACTER",0xff,0xff
CB85: 3A46494C          
CB89: 4C204348          
CB8D: 41524143          
CB91: 544552FF          
CB95: FF                
CB96: 20202063          		defb "   c:COPY CHARACTER",0xff,0xff
CB9A: 3A434F50          
CB9E: 59204348          
CBA2: 41524143          
CBA6: 544552FF          
CBAA: FF                
CBAB: 20202076          		defb "   v:PASTE CHARACTER",0xff,0xff
CBAF: 3A504153          
CBB3: 54452043          
CBB7: 48415241          
CBBB: 43544552          
CBBF: FFFF              
CBC1: 20202020          		defb "    +SHT:PASTE CHARACTER PATTERN",0xff,0xff
CBC5: 2B534854          
CBC9: 3A504153          
CBCD: 54452043          
CBD1: 48415241          
CBD5: 43544552          
CBD9: 20504154          
CBDD: 5445524E          
CBE1: FFFF              
CBE3: 20202020          		defb "    +SHT:PASTE CHARACTER COLOR",0xff,0xff
CBE7: 2B534854          
CBEB: 3A504153          
CBEF: 54452043          
CBF3: 48415241          
CBF7: 43544552          
CBFB: 20434F4C          
CBFF: 4F52FFFF          
CC03: 20202075          		defb "   u:UNDO CHAR",0xff,0xff
CC07: 3A554E44          
CC0B: 4F204348          
CC0F: 4152FFFF          
CC13: 20202079          		defb "   y:QUICK SAVE CHAR (LOSE UNDO)",0
CC17: 3A515549          
CC1B: 434B2053          
CC1F: 41564520          
CC23: 43484152          
CC27: 20284C4F          
CC2B: 53452055          
CC2F: 4E444F29          
CC33: 00                
                        
CC34: 45444954          texthelp7:	defb "EDIT CHARACTER MODE - CONT",0xff,0xff
CC38: 20434841          
CC3C: 52414354          
CC40: 4552204D          
CC44: 4F444520          
CC48: 2D20434F          
CC4C: 4E54FFFF          
CC50: 20202074          		defb "   tab:SWAP WORKING CHARS",0xff,0xff
CC54: 61623A53          
CC58: 57415020          
CC5C: 574F524B          
CC60: 494E4720          
CC64: 43484152          
CC68: 53FFFF            
CC6B: 20202062          		defb "   bs:SAVE WORKING CHARS",0xff,0xff
CC6F: 733A5341          
CC73: 56452057          
CC77: 4F524B49          
CC7B: 4E472043          
CC7F: 48415253          
CC83: FFFF              
CC85: 20202065          		defb "   esc:EXIT WITHOUT SAVING",0xff,0xff
CC89: 73633A45          
CC8D: 58495420          
CC91: 57495448          
CC95: 4F555420          
CC99: 53415649          
CC9D: 4E47FFFF          
CCA1: 2020202E          		defb "   .:EXIT",0
CCA5: 3A455849          
CCA9: 5400              
                        
CCAB: 6F20693A          texthelp8:	defb "o i:SAVE LOAD FILE",0xff,0xff
CCAF: 53415645          
CCB3: 204C4F41          
CCB7: 44204649          
CCBB: 4C45FFFF          
CCBF: 2020205E          		defb "   ^   ^ = MORE FILES",0xff,0xff
CCC3: 2020205E          
CCC7: 203D204D          
CCCB: 4F524520          
CCCF: 46494C45          
CCD3: 53FFFF            
CCD6: 20202061          		defb "   arw:CHOOSE A FILE",0xff,0xff
CCDA: 72773A43          
CCDE: 484F4F53          
CCE2: 45204120          
CCE6: 46494C45          
CCEA: FFFF              
CCEC: 20202065          		defb "   ent(2X):SAVE OR LOAD FILE",0xff,0xff
CCF0: 6E742832          
CCF4: 58293A53          
CCF8: 41564520          
CCFC: 4F52204C          
CD00: 4F414420          
CD04: 46494C45          
CD08: FFFF              
CD0A: 20202073          		defb "   spc:WRITE A NAME",0xff,0xff
CD0E: 70633A57          
CD12: 52495445          
CD16: 2041204E          
CD1A: 414D45FF          
CD1E: FF                
CD1F: 20202065          		defb "   e:CHANGE EXTENSION TO LIST",0xff,0xff
CD23: 3A434841          
CD27: 4E474520          
CD2B: 45585445          
CD2F: 4E53494F          
CD33: 4E20544F          
CD37: 204C4953          
CD3B: 54FFFF            
CD3E: 20202064          		defb "   d:DELETE FILE (ent CONFIRM)",0xff,0xff
CD42: 3A44454C          
CD46: 45544520          
CD4A: 46494C45          
CD4E: 2028656E          
CD52: 7420434F          
CD56: 4E464952          
CD5A: 4D29FFFF          
CD5E: 20202065          		defb "   esc:CANCEL",0
CD62: 73633A43          
CD66: 414E4345          
CD6A: 4C00              
                        
CD6C: 47454E45          texthelp9:	defb "GENERAL CONSIDERATIONS",0xff,0xff
CD70: 52414C20          
CD74: 434F4E53          
CD78: 49444552          
CD7C: 4154494F          
CD80: 4E53FFFF          
CD84: 2A41204C          		defb "*A LOT OF THE tools functions",0xff,0xff
CD88: 4F54204F          
CD8C: 46205448          
CD90: 4520746F          
CD94: 6F6C7320          
CD98: 66756E63          
CD9C: 74696F6E          
CDA0: 73FFFF            
CDA3: 204F4E20          		defb " ON THE edit character SCREEN",0xff,0xff
CDA7: 54484520          
CDAB: 65646974          
CDAF: 20636861          
CDB3: 72616374          
CDB7: 65722053          
CDBB: 43524545          
CDBF: 4EFFFF            
CDC2: 20444550          		defb " DEPEND ON WHERE THE CURSOR IS,",0xff,0xff
CDC6: 454E4420          
CDCA: 4F4E2057          
CDCE: 48455245          
CDD2: 20544845          
CDD6: 20435552          
CDDA: 534F5220          
CDDE: 49532CFF          
CDE2: FF                
CDE3: 20544845          		defb " THE character map OR grid area.",0xff,0xff
CDE7: 20636861          
CDEB: 72616374          
CDEF: 6572206D          
CDF3: 6170204F          
CDF7: 52206772          
CDFB: 69642061          
CDFF: 7265612E          
CE03: FFFF              
CE05: 2A776F72          		defb "*working characters ARE THE GRID",0xff,0xff
CE09: 6B696E67          
CE0D: 20636861          
CE11: 72616374          
CE15: 65727320          
CE19: 41524520          
CE1D: 54484520          
CE21: 47524944          
CE25: FFFF              
CE27: 20414E44          		defb " AND BACKGROUND CHARACTERS ON",0xff,0xff
CE2B: 20424143          
CE2F: 4B47524F          
CE33: 554E4420          
CE37: 43484152          
CE3B: 41435445          
CE3F: 5253204F          
CE43: 4EFFFF            
CE46: 20544845          		defb " THE edit character SCREEN.",0xff,0xff
CE4A: 20656469          
CE4E: 74206368          
CE52: 61726163          
CE56: 74657220          
CE5A: 53435245          
CE5E: 454E2EFF          
CE62: FF                
CE63: 20544845          		defb " THEY CAN BE EDITED AND SAVED",0xff,0xff
CE67: 59204341          
CE6B: 4E204245          
CE6F: 20454449          
CE73: 54454420          
CE77: 414E4420          
CE7B: 53415645          
CE7F: 44FFFF            
CE82: 20464F52          		defb " FOR THE CURRENT SESSION.",0
CE86: 20544845          
CE8A: 20435552          
CE8E: 52454E54          
CE92: 20534553          
CE96: 53494F4E          
CE9A: 2E00              
                        
                        		; custom font data
                        		; from ! to @ first pass gets FONTINT1 and FONTINT2
CE9C: 10101010          fontint1:	defb 0x10,0x10,0x10,0x10,0x10,0x00,0x10,0x00,0x28,0x28,0x00,0x00,0x00,0x00,0x00,0x00
CEA0: 10001000          
CEA4: 28280000          
CEA8: 00000000          
CEAC: 00283828          		defb 0x00,0x28,0x38,0x28,0x38,0x28,0x00,0x00,0x20,0x70,0x40,0x70,0x10,0x70,0x20,0x00
CEB0: 38280000          
CEB4: 20704070          
CEB8: 10702000          
CEBC: 24040810          		defb 0x24,0x04,0x08,0x10,0x20,0x24,0x00,0x00,0x10,0x28,0x10,0x28,0x2c,0x28,0x14,0x00
CEC0: 20240000          
CEC4: 10281028          
CEC8: 2C281400          
CECC: 08100000          		defb 0x08,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x10,0x20,0x20,0x20,0x10,0x08,0x00
CED0: 00000000          
CED4: 08102020          
CED8: 20100800          
CEDC: 20100808          		defb 0x20,0x10,0x08,0x08,0x08,0x10,0x20,0x00,0x00,0x10,0x38,0x10,0x38,0x10,0x00,0x00
CEE0: 08102000          
CEE4: 00103810          
CEE8: 38100000          
CEEC: 00001038          		defb 0x00,0x00,0x10,0x38,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x10,0x00
CEF0: 10000000          
CEF4: 00000000          
CEF8: 00081000          
CEFC: 00000038          		defb 0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00
CF00: 00000000          
CF04: 00000000          
CF08: 00001000          
CF0C: 08081010          		defb 0x08,0x08,0x10,0x10,0x10,0x20,0x20,0x00,0x3c,0x24,0x24,0x24,0x24,0x24,0x3c,0x00
CF10: 10202000          
CF14: 3C242424          
CF18: 24243C00          
CF1C: 08180808          		defb 0x08,0x18,0x08,0x08,0x08,0x08,0x1c,0x00,0x18,0x24,0x04,0x08,0x10,0x20,0x3c,0x00
CF20: 08081C00          
CF24: 18240408          
CF28: 10203C00          
CF2C: 18240408          		defb 0x18,0x24,0x04,0x08,0x04,0x24,0x18,0x00,0x24,0x24,0x24,0x24,0x1c,0x04,0x04,0x00
CF30: 04241800          
CF34: 24242424          
CF38: 1C040400          
CF3C: 3C203804          		defb 0x3c,0x20,0x38,0x04,0x04,0x04,0x38,0x00,0x18,0x10,0x20,0x38,0x24,0x24,0x18,0x00
CF40: 04043800          
CF44: 18102038          
CF48: 24241800          
CF4C: 3C040408          		defb 0x3c,0x04,0x04,0x08,0x08,0x10,0x10,0x00,0x18,0x24,0x24,0x18,0x24,0x24,0x18,0x00
CF50: 08101000          
CF54: 18242418          
CF58: 24241800          
CF5C: 1824241C          		defb 0x18,0x24,0x24,0x1c,0x04,0x08,0x10,0x00,0x00,0x00,0x10,0x00,0x00,0x10,0x00,0x00
CF60: 04081000          
CF64: 00001000          
CF68: 00100000          
CF6C: 00001000          		defb 0x00,0x00,0x10,0x00,0x00,0x10,0x10,0x00,0x00,0x08,0x10,0x20,0x10,0x08,0x00,0x00
CF70: 00101000          
CF74: 00081020          
CF78: 10080000          
CF7C: 00003800          		defb 0x00,0x00,0x38,0x00,0x38,0x00,0x00,0x00,0x00,0x20,0x10,0x08,0x10,0x20,0x00,0x00
CF80: 38000000          
CF84: 00201008          
CF88: 10200000          
CF8C: 18240408          		defb 0x18,0x24,0x04,0x08,0x10,0x00,0x10,0x00,0x18,0x24,0x04,0x14,0x2c,0x24,0x18,0x00
CF90: 10001000          
CF94: 18240414          
CF98: 2C241800          
                        		; Text from A to ACUTE ACCENT: &h0041 - &h0060 (used to fill the lowercases with A-Z)
CF9C: 18242424          fontint2:	defb 0x18,0x24,0x24,0x24,0x3c,0x24,0x24,0x00,0x38,0x24,0x24,0x38,0x24,0x24,0x38,0x00
CFA0: 3C242400          
CFA4: 38242438          
CFA8: 24243800          
CFAC: 18242020          		defb 0x18,0x24,0x20,0x20,0x20,0x24,0x18,0x00,0x38,0x24,0x24,0x24,0x24,0x24,0x38,0x00
CFB0: 20241800          
CFB4: 38242424          
CFB8: 24243800          
CFBC: 3C202038          		defb 0x3c,0x20,0x20,0x38,0x20,0x20,0x3c,0x00,0x3c,0x20,0x20,0x38,0x20,0x20,0x20,0x00
CFC0: 20203C00          
CFC4: 3C202038          
CFC8: 20202000          
CFCC: 1824202C          		defb 0x18,0x24,0x20,0x2c,0x24,0x24,0x18,0x00,0x24,0x24,0x24,0x3c,0x24,0x24,0x24,0x00
CFD0: 24241800          
CFD4: 2424243C          
CFD8: 24242400          
CFDC: 10101010          		defb 0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x04,0x04,0x04,0x04,0x24,0x24,0x18,0x00
CFE0: 10101000          
CFE4: 04040404          
CFE8: 24241800          
CFEC: 24242830          		defb 0x24,0x24,0x28,0x30,0x28,0x24,0x24,0x00,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x00
CFF0: 28242400          
CFF4: 20202020          
CFF8: 20203C00          
CFFC: 243C3C24          		defb 0x24,0x3c,0x3c,0x24,0x24,0x24,0x24,0x00,0x24,0x34,0x34,0x2c,0x2c,0x24,0x24,0x00
D000: 24242400          
D004: 2434342C          
D008: 2C242400          
D00C: 18242424          		defb 0x18,0x24,0x24,0x24,0x24,0x24,0x18,0x00,0x38,0x24,0x24,0x38,0x20,0x20,0x20,0x00
D010: 24241800          
D014: 38242438          
D018: 20202000          
D01C: 18242424          		defb 0x18,0x24,0x24,0x24,0x24,0x2c,0x1c,0x00,0x38,0x24,0x24,0x38,0x24,0x24,0x24,0x00
D020: 242C1C00          
D024: 38242438          
D028: 24242400          
D02C: 18242018          		defb 0x18,0x24,0x20,0x18,0x04,0x24,0x18,0x00,0x38,0x10,0x10,0x10,0x10,0x10,0x10,0x00
D030: 04241800          
D034: 38101010          
D038: 10101000          
D03C: 24242424          		defb 0x24,0x24,0x24,0x24,0x24,0x24,0x18,0x00,0x24,0x24,0x24,0x24,0x24,0x18,0x18,0x00
D040: 24241800          
D044: 24242424          
D048: 24181800          
D04C: 24242424          		defb 0x24,0x24,0x24,0x24,0x3c,0x3c,0x24,0x00,0x24,0x24,0x24,0x18,0x24,0x24,0x24,0x00
D050: 3C3C2400          
D054: 24242418          
D058: 24242400          
D05C: 28282810          		defb 0x28,0x28,0x28,0x10,0x10,0x10,0x10,0x00,0x3c,0x04,0x08,0x10,0x10,0x20,0x3c,0x00
D060: 10101000          
D064: 3C040810          
D068: 10203C00          
D06C: 38202020          		defb 0x38,0x20,0x20,0x20,0x20,0x20,0x38,0x00,0x20,0x20,0x10,0x10,0x10,0x08,0x08,0x00
D070: 20203800          
D074: 20201010          
D078: 10080800          
D07C: 38080808          		defb 0x38,0x08,0x08,0x08,0x08,0x08,0x38,0x00,0x10,0x28,0x00,0x00,0x00,0x00,0x00,0x00
D080: 08083800          
D084: 10280000          
D088: 00000000          
D08C: 00000000          		defb 0x00,0x00,0x00,0x00,0x00,0x00,0x3c,0x00,0x10,0x08,0x00,0x00,0x00,0x00,0x00,0x00
D090: 00003C00          
D094: 10080000          
D098: 00000000          
                        		; text from OPEN CURLY BRACKET to TILDE: &h007b - &h007e
D09C: 08101020          fontint3:	defb 0x08,0x10,0x10,0x20,0x10,0x10,0x08,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x00
D0A0: 10100800          
D0A4: 10101010          
D0A8: 10101000          
D0AC: 20101008          		defb 0x20,0x10,0x10,0x08,0x10,0x10,0x20,0x00,0x00,0x14,0x28,0x00,0x00,0x00,0x00,0x00
D0B0: 10102000          
D0B4: 00142800          
D0B8: 00000000          
D0BC: 00000000          		defs 0x08,0 ; filler for DELTA character to redefine logo using the FONTINT3 routine
D0C0: 00000000          
                        		; small MASCIISDRAWX logo
D0C4: 02020707          Logosmall:	defb 0x02,0x02,0x07,0x07,0x0f,0x0d,0x0c,0x0c,0x21,0x22,0x73,0x72,0xfa,0xd8,0x9f,0x9f
D0C8: 0F0D0C0C          
D0CC: 21227372          
D0D0: FAD89F9F          
D0D4: 19A2928A          		defb 0x19,0xa2,0x92,0x8a,0xb1,0x00,0xff,0xff,0xa9,0x2b,0x2b,0x2b,0xa9,0x00,0xff,0xff
D0D8: B100FFFF          
D0DC: A92B2B2B          
D0E0: A900FFFF          
D0E4: FFFF00F3          		defb 0xff,0xff,0x00,0xf3,0xfa,0x1a,0xfa,0xf3,0xff,0xff,0x00,0x31,0xaa,0xb3,0xaa,0x2a
D0E8: FA1AFAF3          
D0EC: FFFF0031          
D0F0: AAB3AA2A          
D0F4: FEFF0128          		defb 0xfe,0xff,0x01,0x28,0xa8,0xa9,0xbb,0xaa,0x10,0x30,0xe0,0xc0,0xc0,0xe0,0x30,0x10 		; text from EXCLAMATION to AT: &h0021 - &h0040
D0F8: A8A9BBAA          
D0FC: 1030E0C0          
D100: C0E03010          
                        
                        		; line add LUT
                        		;	 11   12   13   14   15   16   17   18   19   1a   1b
                        		;	 ┴    ┬    ┤    ├    ┼    │    ─    ┌    ┐    └    ┘
D104: 15151314          lineaddlut:	defb 0x15,0x15,0x13,0x14,0x15,0x16,0x15,0x14,0x13,0x14,0x13 ; │ 16
D108: 15161514          
D10C: 131413            
D10F: 11121515          		defb 0x11,0x12,0x15,0x15,0x15,0x15,0x17,0x12,0x12,0x11,0x11 ; ─ 17
D113: 15151712          
D117: 121111            
D11A: 15121514          		defb 0x15,0x12,0x15,0x14,0x15,0x14,0x12,0x18,0x12,0x14,0x15 ; ┌ 18
D11E: 15141218          
D122: 121415            
D125: 15121315          		defb 0x15,0x12,0x13,0x15,0x15,0x13,0x12,0x12,0x19,0x15,0x13 ; ┐ 19
D129: 15131212          
D12D: 191513            
D130: 11151514          		defb 0x11,0x15,0x15,0x14,0x15,0x14,0x11,0x14,0x15,0x1a,0x11 ; └ 1a
D134: 15141114          
D138: 151A11            
D13B: 11151315          		defb 0x11,0x15,0x13,0x15,0x15,0x13,0x11,0x15,0x13,0x11,0x1b ; ┘ 1b
D13F: 15131115          
D143: 13111B            
                        
                        		; buffer area for storing VRAM information
D146: 0000              buffcont1:	defb 0x00,0x00	; y,x of buffer 1 content (0,0 if unusable)
D148: 00000000          buffer1:	defs 0x300,0x00	; for copy/paste
D14C: 00...             
D448: 00000000          buffer2:	defs 0x300,0x00	; for temporary stuff (scroll, paste box)
D44C: 00...             
                        ; ------------------------


; +++ segments +++

#CODE          = $B000 = 45056,  size = $2748 = 10056

; +++ global symbols +++

BAKCLR         = $F3EA = 62442          masciiDT.asm:29
BDRCLR         = $F3EB = 62443          masciiDT.asm:30
CSRSW          = $FCA9 = 64681          masciiDT.asm:34
FORCLR         = $F3E9 = 62441          masciiDT.asm:28
LINL32         = $F3AF = 62383          masciiDT.asm:31
Logosmall      = $D0C4 = 53444          masciiDT.asm:260 (unused)
NEWKEY         = $FBE5 = 64485          masciiDT.asm:33
TRGFLG         = $F3E8 = 62440          masciiDT.asm:32
VRBUF1         = $0800 =  2048          masciiDT.asm:38 (unused)
VRBUF2         = $0C00 =  3072          masciiDT.asm:39
VRBUF3         = $1000 =  4096          masciiDT.asm:40
VRBUF4         = $1400 =  5120          masciiDT.asm:41
VRBUF5         = $2800 = 10240          masciiDT.asm:43
VRBUF6         = $3000 = 12288          masciiDT.asm:44
_end           = $D748 = 55112          masciisd.asm:101
_size          = $2748 = 10056          masciisd.asm:101 (unused)
acceptedit     = $BC85 = 48261          masciiEC.asm:169
acnix          = $B914 = 47380          masciiRE.asm:185
acniy          = $B900 = 47360          masciiRE.asm:175
activaterect   = $B855 = 47189          masciiRE.asm:82
add8to16       = $C3E3 = 50147          masciiSR.asm:208
areyousure     = $B3B2 = 46002          masciiMI.asm:293
bascm          = $B007 = 45063          masciiIN.asm:4
beep           = $00C0 =   192          masciiDT.asm:20 (unused)
boxrv          = $C340 = 49984          masciiSR.asm:94
boxvrb1        = $C371 = 50033          masciiSR.asm:133
boxvrb2        = $C377 = 50039          masciiSR.asm:138
breakx         = $00B7 =   183          masciiDT.asm:18 (unused)
buffcont1      = $D146 = 53574          masciiDT.asm:276
buffer1        = $D148 = 53576          masciiDT.asm:277
buffer2        = $D448 = 54344          masciiDT.asm:278
calatr         = $0087 =   135          masciiDT.asm:14
calpat         = $0084 =   132          masciiDT.asm:13
cancelcharmap  = $B28E = 45710          masciiMI.asm:129
canceledit     = $BC67 = 48231          masciiEC.asm:155
cancelpaste    = $B9DD = 47581          masciiRE.asm:302
cancelrect     = $B8B6 = 47286          masciiRE.asm:129
changerect     = $B7EC = 47084          masciiRE.asm:29
chbordcolor    = $C3D0 = 50128          masciiSR.asm:192
checkbutton2   = $B720 = 46880          masciiMI.asm:781
checkcurspos   = $C3F4 = 50164          masciiSR.asm:226
checkmouse     = $B0CE = 45262          masciiIN.asm:117
checktrigger   = $B712 = 46866          masciiMI.asm:771
chgclr         = $0062 =    98          masciiDT.asm:11
chget          = $009F =   159          masciiDT.asm:16
chgmod         = $005F =    95          masciiDT.asm:10 (unused)
chosefrommap   = $B223 = 45603          masciiMI.asm:73
chsns          = $009C =   156          masciiDT.asm:15
cleargridcurs  = $BC3C = 48188          masciiEC.asm:131
clearmapcurs   = $BC24 = 48164          masciiEC.asm:117
clearscr       = $B59B = 46491          masciiMI.asm:562
clearscrchar   = $B5AF = 46511          masciiMI.asm:572
clearscrinit   = $B5CC = 46540          masciiMI.asm:585
cls            = $00C3 =   195          masciiDT.asm:19
clsrestscr     = $B48D = 46221          masciiMI.asm:398
clssavescr     = $B474 = 46196          masciiMI.asm:384
copyscrtobuf2  = $C2D4 = 49876          masciiSR.asm:11
copytovram     = $C2E1 = 49889          masciiSR.asm:18
createcharmap  = $C31E = 49950          masciiSR.asm:68
curat          = $C42D = 50221          masciiDT.asm:47
cursorcolor    = $B54D = 46413          masciiMI.asm:514
cyclebordcol   = $B590 = 46480          masciiMI.asm:554
dcompr         = $0020 =    32          masciiDT.asm:4
drawboxchr     = $B9EB = 47595          masciiRE.asm:311
drawboxfil     = $BA0E = 47630          masciiRE.asm:333
drawboxhol     = $BA2C = 47660          masciiRE.asm:352
drawboxlin     = $BA52 = 47698          masciiRE.asm:375
drawchar       = $B4A1 = 46241          masciiMI.asm:411
drawchcsr      = $B4F2 = 46322          masciiMI.asm:456
drawcsr        = $B4E0 = 46304          masciiMI.asm:446
drawgrid       = $BD33 = 48435          masciiEC.asm:261
drawhorizline  = $BAEC = 47852          masciiRE.asm:460
drawlogosmall  = $C334 = 49972          masciiSR.asm:84
drawrectch     = $BAFD = 47869          masciiRE.asm:472
drawvertline   = $BAE7 = 47847          masciiRE.asm:456
droprequlook   = $B455 = 46165          masciiMI.asm:368
editbgch       = $C548 = 50504          masciiDT.asm:92 (unused)
editbgcl       = $C560 = 50528          masciiDT.asm:96 (unused)
editbkch       = $C568 = 50536          masciiDT.asm:98
editbkcl       = $C580 = 50560          masciiDT.asm:99
editofch       = $C540 = 50496          masciiDT.asm:91 (unused)
editofcl       = $C558 = 50520          masciiDT.asm:95 (unused)
editonch       = $C538 = 50488          masciiDT.asm:90
editoncl       = $C550 = 50512          masciiDT.asm:94
editwork       = $C5A4 = 50596          masciiDT.asm:106
editwrk1       = $C598 = 50584          masciiDT.asm:102
editwrk2       = $C59E = 50590          masciiDT.asm:104
edtbackcolor   = $BE93 = 48787          masciiEC.asm:461
edtch          = $C437 = 50231          masciiDT.asm:49
edtcheckb      = $BEE3 = 48867          masciiEC.asm:522
edtclear       = $BF09 = 48905          masciiEC.asm:543
edtcopy        = $BE16 = 48662          masciiEC.asm:393
edtcopych      = $C441 = 50241          masciiDT.asm:51
edtcopycl      = $C449 = 50249          masciiDT.asm:52
edtfill        = $BEFA = 48890          masciiEC.asm:535
edtfliphrz     = $BF90 = 49040          masciiEC.asm:618
edtflipvrt     = $BF75 = 49013          masciiEC.asm:602
edtfnish       = $BEC6 = 48838          masciiEC.asm:504
edtforecolor   = $BE6D = 48749          masciiEC.asm:439
edthelpch      = $C439 = 50233          masciiDT.asm:50
edtinit        = $BEBF = 48831          masciiEC.asm:498
edtinvert      = $BED0 = 48848          masciiEC.asm:511
edtpaste       = $BE37 = 48695          masciiEC.asm:410
edtrollchar    = $BDB2 = 48562          masciiEC.asm:345
edtrotlft      = $BFD5 = 49109          masciiEC.asm:656
edtrotrgt      = $BFAF = 49071          masciiEC.asm:635
edtscrdwn      = $BF55 = 48981          masciiEC.asm:584
edtscrlft      = $BF18 = 48920          masciiEC.asm:551
edtscrlrgt     = $BF2C = 48940          masciiEC.asm:562
edtscrup       = $BF40 = 48960          masciiEC.asm:573
edtsetundo     = $BDCA = 48586          masciiEC.asm:357
edtundo        = $BDEC = 48620          masciiEC.asm:373
edtundoch      = $C451 = 50257          masciiDT.asm:53
edtundocl      = $C459 = 50265          masciiDT.asm:54
enterredit     = $BCAE = 48302          masciiEC.asm:189
entertext      = $B2B8 = 45752          masciiMI.asm:151
erafnk         = $00CC =   204          masciiDT.asm:22
erasechar      = $B4AE = 46254          masciiMI.asm:418
erasewithbox   = $B9C2 = 47554          masciiRE.asm:289
fileinput      = $B19A = 45466          masciiMI.asm:5
fileoutput     = $B1B0 = 45488          masciiMI.asm:16
filvrm         = $0056 =    86          masciiDT.asm:7
fixscrollcol   = $B663 = 46691          masciiMI.asm:658
fixycoord      = $B760 = 46944          masciiMI.asm:825
flags          = $B008 = 45064          masciiIN.asm:8
flipscrhorz    = $B6C0 = 46784          masciiMI.asm:717
flipscrvert    = $B673 = 46707          masciiMI.asm:671
fontint1       = $CE9C = 52892          masciiDT.asm:222
fontint2       = $CF9C = 53148          masciiDT.asm:239
fontint3       = $D09C = 53404          masciiDT.asm:256
getcharcolor   = $B52D = 46381          masciiMI.asm:489
getcharkey     = $B2EC = 45804          masciiMI.asm:183
getcharshape   = $B51C = 46364          masciiMI.asm:477
getchrfromarea = $BDA1 = 48545          masciiEC.asm:335
getcolorfrchr  = $BEA9 = 48809          masciiEC.asm:475
geterasechar   = $B27C = 45692          masciiMI.asm:120
getfrommap     = $B281 = 45697          masciiMI.asm:123
getmouse       = $B770 = 46960          masciiMI.asm:837
getpastebox    = $B957 = 47447          masciiRE.asm:226
getpasteold    = $B963 = 47459          masciiRE.asm:231
getpatternad   = $BEB6 = 48822          masciiEC.asm:486
getrequlook    = $B3EA = 46058          masciiMI.asm:325
getvramrectpos = $B8EC = 47340          masciiRE.asm:161
gtofst         = $B7B0 = 47024          masciiMI.asm:882
gttrig         = $00D8 =   216          masciiDT.asm:23 (unused)
hideboxcur     = $C3B5 = 50101          masciiSR.asm:180
hidecharcur    = $C3A6 = 50086          masciiSR.asm:172
hidecur        = $C39D = 50077          masciiSR.asm:166
hlptxt         = $C5E0 = 50656          masciiDT.asm:117
init32         = $006F =   111          masciiDT.asm:12
initgrid       = $BCCB = 48331          masciiEC.asm:205
initsprites    = $B08F = 45199          masciiIN.asm:82
initsprmem     = $B060 = 45152          masciiIN.asm:46
initworkchrs   = $BB75 = 47989          masciiEC.asm:33
inlin          = $00B1 =   177          masciiDT.asm:17
insidecharmap  = $BC33 = 48179          masciiEC.asm:125
insideeditarea = $BC45 = 48197          masciiEC.asm:137
kilbuf         = $0156 =   342          masciiDT.asm:25
lbxrv          = $C348 = 49992          masciiSR.asm:99
lbxvr          = $C37E = 50046          masciiSR.asm:142
lchmo          = $B0D0 = 45264          masciiIN.asm:119
lcuco          = $B55D = 46429          masciiMI.asm:522
ldbc1          = $BA01 = 47617          masciiRE.asm:323
ldbc2          = $BA00 = 47616          masciiRE.asm:322
ldbfl          = $BA1A = 47642          masciiRE.asm:340
ldirmv         = $0059 =    89          masciiDT.asm:8
ldirvm         = $005C =    92          masciiDT.asm:9
ldls1          = $C338 = 49976          masciiSR.asm:88
ldrli          = $BAF3 = 47859          masciiRE.asm:466
ldrre          = $BB1B = 47899          masciiRE.asm:496
leckbd         = $BEE8 = 48872          masciiEC.asm:525
lefh1          = $BF99 = 49049          masciiEC.asm:623
lefv1          = $BF80 = 49024          masciiEC.asm:608
lefv2          = $BF7A = 49018          masciiEC.asm:605
leinv          = $BED5 = 48853          masciiEC.asm:514
lerl1          = $BFDA = 49114          masciiEC.asm:659
lerl2          = $BFE3 = 49123          masciiEC.asm:663
lerr1          = $BFB4 = 49076          masciiEC.asm:638
lerr2          = $BFBD = 49085          masciiEC.asm:642
lescd          = $BF62 = 48994          masciiEC.asm:591
lescl          = $BF1D = 48925          masciiEC.asm:554
lescr          = $BF31 = 48945          masciiEC.asm:565
lfsh1          = $B6CD = 46797          masciiMI.asm:724
lfsv1          = $B680 = 46720          masciiMI.asm:678
lfsv2          = $B69C = 46748          masciiMI.asm:697
lfsv3          = $B6A6 = 46758          masciiMI.asm:702
lgrd1          = $BD46 = 48454          masciiEC.asm:276
lgrd2          = $BD4D = 48461          masciiEC.asm:281
lineaddlut     = $D104 = 53508          masciiDT.asm:268
linme          = $B069 = 45161          masciiIN.asm:51
lisp1          = $B0A8 = 45224          masciiIN.asm:98
lisp2          = $B0BE = 45246          masciiIN.asm:108
lisp3          = $B094 = 45204          masciiIN.asm:86
lpctv          = $C2E3 = 49891          masciiSR.asm:23
lsec1          = $C326 = 49958          masciiSR.asm:74
lshh1          = $B363 = 45923          masciiMI.asm:251
lshh2          = $B35D = 45917          masciiMI.asm:249
lssh2          = $B6FA = 46842          masciiMI.asm:754
lssh3          = $B700 = 46848          masciiMI.asm:757
lstv1          = $C30C = 49932          masciiSR.asm:55
lupc1          = $BD12 = 48402          masciiEC.asm:241
lupc2          = $BD11 = 48401          masciiEC.asm:240
lwrtx          = $B32A = 45866          masciiMI.asm:218
lwspc          = $B34A = 45898          masciiMI.asm:238
mainloop       = $B0E2 = 45282          masciiML.asm:3
movcurhor      = $B745 = 46917          masciiMI.asm:806
movcurver      = $B751 = 46929          masciiMI.asm:815
movecursor     = $B733 = 46899          masciiMI.asm:795
ncmk2          = $C1CC = 49612          masciiKB.asm:239
ncmk7          = $C1E2 = 49634          masciiKB.asm:249
neck0          = $C20A = 49674          masciiKB.asm:271
neck2          = $C21B = 49691          masciiKB.asm:279
neck3          = $C240 = 49728          masciiKB.asm:295
neck4          = $C25B = 49755          masciiKB.asm:307
neck5          = $C2A8 = 49832          masciiKB.asm:341
neck7          = $C2C3 = 49859          masciiKB.asm:353
ngek2          = $C022 = 49186          masciiKB.asm:22
ngek3          = $C053 = 49235          masciiKB.asm:44
ngek4          = $C078 = 49272          masciiKB.asm:61
ngek5          = $C0BA = 49338          masciiKB.asm:90
ngek7          = $C0DB = 49371          masciiKB.asm:105
nmak0          = $C0F5 = 49397          masciiKB.asm:121
nmak1          = $C10A = 49418          masciiKB.asm:131
nmak4          = $C118 = 49432          masciiKB.asm:144
nmak8          = $C152 = 49490          masciiKB.asm:170
npak3          = $C193 = 49555          masciiKB.asm:210
npak5          = $C1A9 = 49577          masciiKB.asm:220
npak7          = $C1BF = 49599          masciiKB.asm:230
nrek2          = $C15F = 49503          masciiKB.asm:179
nrek3          = $C16B = 49515          masciiKB.asm:185
nrek7          = $C181 = 49537          masciiKB.asm:199
pasteoldbuf    = $B93C = 47420          masciiRE.asm:210
pastethebox    = $B9B2 = 47538          masciiRE.asm:281
pickchar       = $B4CC = 46284          masciiMI.asm:434
posit          = $00C6 =   198          masciiDT.asm:21
preparerect    = $B7C0 = 47040          masciiRE.asm:3
preprectcurs   = $B8C4 = 47300          masciiRE.asm:138
rdvrm          = $004A =    74          masciiDT.asm:5
readchmapkeys  = $C1C0 = 49600          masciiKB.asm:233
readedchkeys   = $C1E3 = 49635          masciiKB.asm:252
readgenkeys    = $BFFB = 49147          masciiKB.asm:3
readmainkeys   = $C0DC = 49372          masciiKB.asm:108
readpastbxkeys = $C182 = 49538          masciiKB.asm:202
readrectkeys   = $C153 = 49491          masciiKB.asm:173
rectt          = $C467 = 50279          masciiDT.asm:56
restworkchrs   = $BBC0 = 48064          masciiEC.asm:68
return         = $B00D = 45069          masciiIN.asm:13 (unused)
rollchar       = $B4BB = 46267          masciiMI.asm:425
savewrkchrs    = $BC02 = 48130          masciiEC.asm:101
says1          = $B3E4 = 46052          masciiMI.asm:320
sbxrv          = $C360 = 50016          masciiSR.asm:118
schr1          = $B7FA = 47098          masciiRE.asm:37
scrat          = $C461 = 50273          masciiDT.asm:55
scrolldown     = $B608 = 46600          masciiMI.asm:613
scrollleft     = $B645 = 46661          masciiMI.asm:643
scrollright    = $B627 = 46631          masciiMI.asm:628
scrollup       = $B5E9 = 46569          masciiMI.asm:598
sdbl1          = $BA66 = 47718          masciiRE.asm:386
sdbl2          = $BA78 = 47736          masciiRE.asm:396
sdbl3          = $BA8A = 47754          masciiRE.asm:405
sdrli          = $BAEF = 47855          masciiRE.asm:463
sdrr1          = $BB32 = 47922          masciiRE.asm:513
sebc1          = $BE96 = 48790          masciiEC.asm:463 (unused)
seco1          = $BE19 = 48665          masciiEC.asm:396 (unused)
sefc1          = $BE70 = 48752          masciiEC.asm:441 (unused)
sepa1          = $BE4D = 48717          masciiEC.asm:423
sepa2          = $BE5E = 48734          masciiEC.asm:432
sepa3          = $BE3A = 48698          masciiEC.asm:412 (unused)
sepa4          = $BE69 = 48745          masciiEC.asm:436
setquit        = $B1C6 = 45510          masciiMI.asm:27
setundo        = $C2C4 = 49860          masciiSR.asm:3
sfsv1          = $B6BC = 46780          masciiMI.asm:714
sfycoo         = $B76A = 46954          masciiMI.asm:832
sgfm1          = $B284 = 45700          masciiMI.asm:125
sgrd1          = $BD54 = 48468          masciiEC.asm:285
sgrd2          = $BD66 = 48486          masciiEC.asm:297
sgtm1          = $B7AA = 47018          masciiMI.asm:877
sgtm2          = $B7AD = 47021          masciiMI.asm:879
showcharmap    = $B1DE = 45534          masciiMI.asm:41
showeditchrscr = $BB37 = 47927          masciiEC.asm:3
showhelp       = $B354 = 45908          masciiMI.asm:245
showpastebox   = $B973 = 47475          masciiRE.asm:241
showrectcurs   = $B804 = 47108          masciiRE.asm:42
smcmp          = $B16A = 45418          masciiML.asm:58
smedc          = $B18B = 45451          masciiML.asm:71
smgin          = $B107 = 45319          masciiML.asm:18
smmse          = $B114 = 45332          masciiML.asm:24
smpbx          = $B14E = 45390          masciiML.asm:47
smrct          = $B130 = 45360          masciiML.asm:35
snsmat         = $0141 =   321          masciiDT.asm:24 (unused)
spbckgrd       = $C527 = 50471          masciiDT.asm:85
spboxadd       = $C4B0 = 50352          masciiDT.asm:69
spboxchr       = $C4C1 = 50369          masciiDT.asm:71 (unused)
spboxfil       = $C47D = 50301          masciiDT.asm:63
spboxhol       = $C48E = 50318          masciiDT.asm:65
spboxlin       = $C49F = 50335          masciiDT.asm:67
spcharac       = $C516 = 50454          masciiDT.asm:82
spcursor       = $C46C = 50284          masciiDT.asm:61
speditch       = $C4F4 = 50420          masciiDT.asm:77
spfrstal       = $C46C = 50284          masciiDT.asm:60
spimcopy       = $C4D2 = 50386          masciiDT.asm:73 (unused)
spimpast       = $C4E3 = 50403          masciiDT.asm:75 (unused)
splastal       = $C527 = 50471          masciiDT.asm:84
splastcu       = $C505 = 50437          masciiDT.asm:79
sptextent      = $C505 = 50437          masciiDT.asm:80
sshh1          = $B394 = 45972          masciiMI.asm:276
sshh2          = $B3A6 = 45990          masciiMI.asm:284
sshh3          = $B39E = 45982          masciiMI.asm:281
sssh1          = $B70E = 46862          masciiMI.asm:766
sstr1          = $B04C = 45132          masciiIN.asm:38
sstr2          = $B043 = 45123          masciiIN.asm:35
sstr3          = $B04F = 45135          masciiIN.asm:39
start          = $B01D = 45085          masciiIN.asm:21
stga1          = $BD9E = 48542          masciiEC.asm:331
stgg1          = $BCF4 = 48372          masciiEC.asm:226
stma1          = $BD83 = 48515          masciiEC.asm:313
streamvv       = $C30B = 49931          masciiSR.asm:52
swapbuffers    = $B583 = 46467          masciiMI.asm:547
swapvv         = $C2ED = 49901          masciiSR.asm:31
swapwrkchrs    = $BBE1 = 48097          masciiEC.asm:85
swext          = $B352 = 45906          masciiMI.asm:242
swret          = $B343 = 45891          masciiMI.asm:234
swscr          = $B00A = 45066          masciiIN.asm:11 (unused)
swtvr          = $C40E = 50190          masciiSR.asm:248
testgridrea    = $BD86 = 48518          masciiEC.asm:317
testmaparea    = $BD6B = 48491          masciiEC.asm:300
textclear      = $C5AA = 50602          masciiDT.asm:111
texthelp1      = $C5F2 = 50674          masciiDT.asm:122
texthelp2      = $C6B0 = 50864          masciiDT.asm:134
texthelp3      = $C7C8 = 51144          masciiDT.asm:146
texthelp4      = $C8D9 = 51417          masciiDT.asm:158
texthelp5      = $C9EC = 51692          masciiDT.asm:170
texthelp6      = $CB23 = 52003          masciiDT.asm:182
texthelp7      = $CC34 = 52276          masciiDT.asm:194
texthelp8      = $CCAB = 52395          masciiDT.asm:200
texthelp9      = $CD6C = 52588          masciiDT.asm:209
textquit       = $C5C4 = 50628          masciiDT.asm:113
textreset      = $C5B7 = 50615          masciiDT.asm:112
textsure       = $C5D1 = 50641          masciiDT.asm:114
toggleflags    = $C3E9 = 50153          masciiSR.asm:218
triggeredit    = $BCB5 = 48309          masciiEC.asm:194
triggergrid    = $BCD8 = 48344          masciiEC.asm:212
triggermap     = $BCC2 = 48322          masciiEC.asm:201
turnoffmouse   = $B0DC = 45276          masciiIN.asm:126
undolast       = $B576 = 46454          masciiMI.asm:540
updatechar     = $BD07 = 48391          masciiEC.asm:234
vrampos        = $C410 = 50192          masciiSR.asm:251
waittrgrls     = $B728 = 46888          masciiMI.asm:788
writetext      = $B328 = 45864          masciiMI.asm:213
wrtvrm         = $004D =    77          masciiDT.asm:6
wrtvrms        = $C3FE = 50174          masciiSR.asm:235


total time: 0.0483 sec.
no errors
